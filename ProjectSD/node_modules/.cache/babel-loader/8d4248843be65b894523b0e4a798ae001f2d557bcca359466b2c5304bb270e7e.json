{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AttributeMap = exports.OpIterator = exports.Op = void 0;\nconst diff = require(\"fast-diff\");\nconst cloneDeep = require(\"lodash.clonedeep\");\nconst isEqual = require(\"lodash.isequal\");\nconst AttributeMap_1 = require(\"./AttributeMap\");\nexports.AttributeMap = AttributeMap_1.default;\nconst Op_1 = require(\"./Op\");\nexports.Op = Op_1.default;\nconst OpIterator_1 = require(\"./OpIterator\");\nexports.OpIterator = OpIterator_1.default;\nconst NULL_CHARACTER = String.fromCharCode(0); // Placeholder char for embed in diff()\nconst getEmbedTypeAndData = (a, b) => {\n  if (typeof a !== 'object' || a === null) {\n    throw new Error(`cannot retain a ${typeof a}`);\n  }\n  if (typeof b !== 'object' || b === null) {\n    throw new Error(`cannot retain a ${typeof b}`);\n  }\n  const embedType = Object.keys(a)[0];\n  if (!embedType || embedType !== Object.keys(b)[0]) {\n    throw new Error(`embed types not matched: ${embedType} != ${Object.keys(b)[0]}`);\n  }\n  return [embedType, a[embedType], b[embedType]];\n};\nclass Delta {\n  constructor(ops) {\n    // Assume we are given a well formed ops\n    if (Array.isArray(ops)) {\n      this.ops = ops;\n    } else if (ops != null && Array.isArray(ops.ops)) {\n      this.ops = ops.ops;\n    } else {\n      this.ops = [];\n    }\n  }\n  static registerEmbed(embedType, handler) {\n    this.handlers[embedType] = handler;\n  }\n  static unregisterEmbed(embedType) {\n    delete this.handlers[embedType];\n  }\n  static getHandler(embedType) {\n    const handler = this.handlers[embedType];\n    if (!handler) {\n      throw new Error(`no handlers for embed type \"${embedType}\"`);\n    }\n    return handler;\n  }\n  insert(arg, attributes) {\n    const newOp = {};\n    if (typeof arg === 'string' && arg.length === 0) {\n      return this;\n    }\n    newOp.insert = arg;\n    if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {\n      newOp.attributes = attributes;\n    }\n    return this.push(newOp);\n  }\n  delete(length) {\n    if (length <= 0) {\n      return this;\n    }\n    return this.push({\n      delete: length\n    });\n  }\n  retain(length, attributes) {\n    if (typeof length === 'number' && length <= 0) {\n      return this;\n    }\n    const newOp = {\n      retain: length\n    };\n    if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {\n      newOp.attributes = attributes;\n    }\n    return this.push(newOp);\n  }\n  push(newOp) {\n    let index = this.ops.length;\n    let lastOp = this.ops[index - 1];\n    newOp = cloneDeep(newOp);\n    if (typeof lastOp === 'object') {\n      if (typeof newOp.delete === 'number' && typeof lastOp.delete === 'number') {\n        this.ops[index - 1] = {\n          delete: lastOp.delete + newOp.delete\n        };\n        return this;\n      }\n      // Since it does not matter if we insert before or after deleting at the same index,\n      // always prefer to insert first\n      if (typeof lastOp.delete === 'number' && newOp.insert != null) {\n        index -= 1;\n        lastOp = this.ops[index - 1];\n        if (typeof lastOp !== 'object') {\n          this.ops.unshift(newOp);\n          return this;\n        }\n      }\n      if (isEqual(newOp.attributes, lastOp.attributes)) {\n        if (typeof newOp.insert === 'string' && typeof lastOp.insert === 'string') {\n          this.ops[index - 1] = {\n            insert: lastOp.insert + newOp.insert\n          };\n          if (typeof newOp.attributes === 'object') {\n            this.ops[index - 1].attributes = newOp.attributes;\n          }\n          return this;\n        } else if (typeof newOp.retain === 'number' && typeof lastOp.retain === 'number') {\n          this.ops[index - 1] = {\n            retain: lastOp.retain + newOp.retain\n          };\n          if (typeof newOp.attributes === 'object') {\n            this.ops[index - 1].attributes = newOp.attributes;\n          }\n          return this;\n        }\n      }\n    }\n    if (index === this.ops.length) {\n      this.ops.push(newOp);\n    } else {\n      this.ops.splice(index, 0, newOp);\n    }\n    return this;\n  }\n  chop() {\n    const lastOp = this.ops[this.ops.length - 1];\n    if (lastOp && typeof lastOp.retain === 'number' && !lastOp.attributes) {\n      this.ops.pop();\n    }\n    return this;\n  }\n  filter(predicate) {\n    return this.ops.filter(predicate);\n  }\n  forEach(predicate) {\n    this.ops.forEach(predicate);\n  }\n  map(predicate) {\n    return this.ops.map(predicate);\n  }\n  partition(predicate) {\n    const passed = [];\n    const failed = [];\n    this.forEach(op => {\n      const target = predicate(op) ? passed : failed;\n      target.push(op);\n    });\n    return [passed, failed];\n  }\n  reduce(predicate, initialValue) {\n    return this.ops.reduce(predicate, initialValue);\n  }\n  changeLength() {\n    return this.reduce((length, elem) => {\n      if (elem.insert) {\n        return length + Op_1.default.length(elem);\n      } else if (elem.delete) {\n        return length - elem.delete;\n      }\n      return length;\n    }, 0);\n  }\n  length() {\n    return this.reduce((length, elem) => {\n      return length + Op_1.default.length(elem);\n    }, 0);\n  }\n  slice(start = 0, end = Infinity) {\n    const ops = [];\n    const iter = new OpIterator_1.default(this.ops);\n    let index = 0;\n    while (index < end && iter.hasNext()) {\n      let nextOp;\n      if (index < start) {\n        nextOp = iter.next(start - index);\n      } else {\n        nextOp = iter.next(end - index);\n        ops.push(nextOp);\n      }\n      index += Op_1.default.length(nextOp);\n    }\n    return new Delta(ops);\n  }\n  compose(other) {\n    const thisIter = new OpIterator_1.default(this.ops);\n    const otherIter = new OpIterator_1.default(other.ops);\n    const ops = [];\n    const firstOther = otherIter.peek();\n    if (firstOther != null && typeof firstOther.retain === 'number' && firstOther.attributes == null) {\n      let firstLeft = firstOther.retain;\n      while (thisIter.peekType() === 'insert' && thisIter.peekLength() <= firstLeft) {\n        firstLeft -= thisIter.peekLength();\n        ops.push(thisIter.next());\n      }\n      if (firstOther.retain - firstLeft > 0) {\n        otherIter.next(firstOther.retain - firstLeft);\n      }\n    }\n    const delta = new Delta(ops);\n    while (thisIter.hasNext() || otherIter.hasNext()) {\n      if (otherIter.peekType() === 'insert') {\n        delta.push(otherIter.next());\n      } else if (thisIter.peekType() === 'delete') {\n        delta.push(thisIter.next());\n      } else {\n        const length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n        const thisOp = thisIter.next(length);\n        const otherOp = otherIter.next(length);\n        if (otherOp.retain) {\n          const newOp = {};\n          if (typeof thisOp.retain === 'number') {\n            newOp.retain = typeof otherOp.retain === 'number' ? length : otherOp.retain;\n          } else {\n            if (typeof otherOp.retain === 'number') {\n              if (thisOp.retain == null) {\n                newOp.insert = thisOp.insert;\n              } else {\n                newOp.retain = thisOp.retain;\n              }\n            } else {\n              const action = thisOp.retain == null ? 'insert' : 'retain';\n              const [embedType, thisData, otherData] = getEmbedTypeAndData(thisOp[action], otherOp.retain);\n              const handler = Delta.getHandler(embedType);\n              newOp[action] = {\n                [embedType]: handler.compose(thisData, otherData, action === 'retain')\n              };\n            }\n          }\n          // Preserve null when composing with a retain, otherwise remove it for inserts\n          const attributes = AttributeMap_1.default.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');\n          if (attributes) {\n            newOp.attributes = attributes;\n          }\n          delta.push(newOp);\n          // Optimization if rest of other is just retain\n          if (!otherIter.hasNext() && isEqual(delta.ops[delta.ops.length - 1], newOp)) {\n            const rest = new Delta(thisIter.rest());\n            return delta.concat(rest).chop();\n          }\n          // Other op should be delete, we could be an insert or retain\n          // Insert + delete cancels out\n        } else if (typeof otherOp.delete === 'number' && (typeof thisOp.retain === 'number' || typeof thisOp.retain === 'object' && thisOp.retain !== null)) {\n          delta.push(otherOp);\n        }\n      }\n    }\n    return delta.chop();\n  }\n  concat(other) {\n    const delta = new Delta(this.ops.slice());\n    if (other.ops.length > 0) {\n      delta.push(other.ops[0]);\n      delta.ops = delta.ops.concat(other.ops.slice(1));\n    }\n    return delta;\n  }\n  diff(other, cursor) {\n    if (this.ops === other.ops) {\n      return new Delta();\n    }\n    const strings = [this, other].map(delta => {\n      return delta.map(op => {\n        if (op.insert != null) {\n          return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER;\n        }\n        const prep = delta === other ? 'on' : 'with';\n        throw new Error('diff() called ' + prep + ' non-document');\n      }).join('');\n    });\n    const retDelta = new Delta();\n    const diffResult = diff(strings[0], strings[1], cursor, true);\n    const thisIter = new OpIterator_1.default(this.ops);\n    const otherIter = new OpIterator_1.default(other.ops);\n    diffResult.forEach(component => {\n      let length = component[1].length;\n      while (length > 0) {\n        let opLength = 0;\n        switch (component[0]) {\n          case diff.INSERT:\n            opLength = Math.min(otherIter.peekLength(), length);\n            retDelta.push(otherIter.next(opLength));\n            break;\n          case diff.DELETE:\n            opLength = Math.min(length, thisIter.peekLength());\n            thisIter.next(opLength);\n            retDelta.delete(opLength);\n            break;\n          case diff.EQUAL:\n            opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);\n            const thisOp = thisIter.next(opLength);\n            const otherOp = otherIter.next(opLength);\n            if (isEqual(thisOp.insert, otherOp.insert)) {\n              retDelta.retain(opLength, AttributeMap_1.default.diff(thisOp.attributes, otherOp.attributes));\n            } else {\n              retDelta.push(otherOp).delete(opLength);\n            }\n            break;\n        }\n        length -= opLength;\n      }\n    });\n    return retDelta.chop();\n  }\n  eachLine(predicate, newline = '\\n') {\n    const iter = new OpIterator_1.default(this.ops);\n    let line = new Delta();\n    let i = 0;\n    while (iter.hasNext()) {\n      if (iter.peekType() !== 'insert') {\n        return;\n      }\n      const thisOp = iter.peek();\n      const start = Op_1.default.length(thisOp) - iter.peekLength();\n      const index = typeof thisOp.insert === 'string' ? thisOp.insert.indexOf(newline, start) - start : -1;\n      if (index < 0) {\n        line.push(iter.next());\n      } else if (index > 0) {\n        line.push(iter.next(index));\n      } else {\n        if (predicate(line, iter.next(1).attributes || {}, i) === false) {\n          return;\n        }\n        i += 1;\n        line = new Delta();\n      }\n    }\n    if (line.length() > 0) {\n      predicate(line, {}, i);\n    }\n  }\n  invert(base) {\n    const inverted = new Delta();\n    this.reduce((baseIndex, op) => {\n      if (op.insert) {\n        inverted.delete(Op_1.default.length(op));\n      } else if (typeof op.retain === 'number' && op.attributes == null) {\n        inverted.retain(op.retain);\n        return baseIndex + op.retain;\n      } else if (op.delete || typeof op.retain === 'number') {\n        const length = op.delete || op.retain;\n        const slice = base.slice(baseIndex, baseIndex + length);\n        slice.forEach(baseOp => {\n          if (op.delete) {\n            inverted.push(baseOp);\n          } else if (op.retain && op.attributes) {\n            inverted.retain(Op_1.default.length(baseOp), AttributeMap_1.default.invert(op.attributes, baseOp.attributes));\n          }\n        });\n        return baseIndex + length;\n      } else if (typeof op.retain === 'object' && op.retain !== null) {\n        const slice = base.slice(baseIndex, baseIndex + 1);\n        const baseOp = new OpIterator_1.default(slice.ops).next();\n        const [embedType, opData, baseOpData] = getEmbedTypeAndData(op.retain, baseOp.insert);\n        const handler = Delta.getHandler(embedType);\n        inverted.retain({\n          [embedType]: handler.invert(opData, baseOpData)\n        }, AttributeMap_1.default.invert(op.attributes, baseOp.attributes));\n        return baseIndex + 1;\n      }\n      return baseIndex;\n    }, 0);\n    return inverted.chop();\n  }\n  transform(arg, priority = false) {\n    priority = !!priority;\n    if (typeof arg === 'number') {\n      return this.transformPosition(arg, priority);\n    }\n    const other = arg;\n    const thisIter = new OpIterator_1.default(this.ops);\n    const otherIter = new OpIterator_1.default(other.ops);\n    const delta = new Delta();\n    while (thisIter.hasNext() || otherIter.hasNext()) {\n      if (thisIter.peekType() === 'insert' && (priority || otherIter.peekType() !== 'insert')) {\n        delta.retain(Op_1.default.length(thisIter.next()));\n      } else if (otherIter.peekType() === 'insert') {\n        delta.push(otherIter.next());\n      } else {\n        const length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n        const thisOp = thisIter.next(length);\n        const otherOp = otherIter.next(length);\n        if (thisOp.delete) {\n          // Our delete either makes their delete redundant or removes their retain\n          continue;\n        } else if (otherOp.delete) {\n          delta.push(otherOp);\n        } else {\n          const thisData = thisOp.retain;\n          const otherData = otherOp.retain;\n          let transformedData = typeof otherData === 'object' && otherData !== null ? otherData : length;\n          if (typeof thisData === 'object' && thisData !== null && typeof otherData === 'object' && otherData !== null) {\n            const embedType = Object.keys(thisData)[0];\n            if (embedType === Object.keys(otherData)[0]) {\n              const handler = Delta.getHandler(embedType);\n              if (handler) {\n                transformedData = {\n                  [embedType]: handler.transform(thisData[embedType], otherData[embedType], priority)\n                };\n              }\n            }\n          }\n          // We retain either their retain or insert\n          delta.retain(transformedData, AttributeMap_1.default.transform(thisOp.attributes, otherOp.attributes, priority));\n        }\n      }\n    }\n    return delta.chop();\n  }\n  transformPosition(index, priority = false) {\n    priority = !!priority;\n    const thisIter = new OpIterator_1.default(this.ops);\n    let offset = 0;\n    while (thisIter.hasNext() && offset <= index) {\n      const length = thisIter.peekLength();\n      const nextType = thisIter.peekType();\n      thisIter.next();\n      if (nextType === 'delete') {\n        index -= Math.min(length, index - offset);\n        continue;\n      } else if (nextType === 'insert' && (offset < index || !priority)) {\n        index += length;\n      }\n      offset += length;\n    }\n    return index;\n  }\n}\nDelta.Op = Op_1.default;\nDelta.OpIterator = OpIterator_1.default;\nDelta.AttributeMap = AttributeMap_1.default;\nDelta.handlers = {};\nexports.default = Delta;\nif (typeof module === 'object') {\n  module.exports = Delta;\n  module.exports.default = Delta;\n}","map":{"version":3,"names":["diff","require","cloneDeep","isEqual","AttributeMap_1","exports","AttributeMap","default","Op_1","Op","OpIterator_1","OpIterator","NULL_CHARACTER","String","fromCharCode","getEmbedTypeAndData","a","b","Error","embedType","Object","keys","Delta","constructor","ops","Array","isArray","registerEmbed","handler","handlers","unregisterEmbed","getHandler","insert","arg","attributes","newOp","length","push","delete","retain","index","lastOp","unshift","splice","chop","pop","filter","predicate","forEach","map","partition","passed","failed","op","target","reduce","initialValue","changeLength","elem","slice","start","end","Infinity","iter","hasNext","nextOp","next","compose","other","thisIter","otherIter","firstOther","peek","firstLeft","peekType","peekLength","delta","Math","min","thisOp","otherOp","action","thisData","otherData","rest","concat","cursor","strings","prep","join","retDelta","diffResult","component","opLength","INSERT","DELETE","EQUAL","eachLine","newline","line","i","indexOf","invert","base","inverted","baseIndex","baseOp","opData","baseOpData","transform","priority","transformPosition","transformedData","offset","nextType","module"],"sources":["C:\\Users\\Agasthya Samyak Jnan\\ProjectSD\\frontend\\node_modules\\quill-delta\\src\\Delta.ts"],"sourcesContent":["import * as diff from 'fast-diff';\nimport cloneDeep = require('lodash.clonedeep');\nimport isEqual = require('lodash.isequal');\nimport AttributeMap from './AttributeMap';\nimport Op from './Op';\nimport OpIterator from './OpIterator';\n\nconst NULL_CHARACTER = String.fromCharCode(0); // Placeholder char for embed in diff()\n\ninterface EmbedHandler<T> {\n  compose(a: T, b: T, keepNull: boolean): T;\n  invert(a: T, b: T): T;\n  transform(a: T, b: T, priority: boolean): T;\n}\n\nconst getEmbedTypeAndData = (\n  a: Op['insert'] | Op['retain'],\n  b: Op['insert'],\n): [string, unknown, unknown] => {\n  if (typeof a !== 'object' || a === null) {\n    throw new Error(`cannot retain a ${typeof a}`);\n  }\n  if (typeof b !== 'object' || b === null) {\n    throw new Error(`cannot retain a ${typeof b}`);\n  }\n  const embedType = Object.keys(a)[0];\n  if (!embedType || embedType !== Object.keys(b)[0]) {\n    throw new Error(\n      `embed types not matched: ${embedType} != ${Object.keys(b)[0]}`,\n    );\n  }\n  return [embedType, a[embedType], b[embedType]];\n};\n\nclass Delta {\n  static Op = Op;\n  static OpIterator = OpIterator;\n  static AttributeMap = AttributeMap;\n  private static handlers: { [embedType: string]: EmbedHandler<unknown> } = {};\n\n  static registerEmbed<T>(embedType: string, handler: EmbedHandler<T>): void {\n    this.handlers[embedType] = handler;\n  }\n\n  static unregisterEmbed(embedType: string): void {\n    delete this.handlers[embedType];\n  }\n\n  private static getHandler(embedType: string): EmbedHandler<unknown> {\n    const handler = this.handlers[embedType];\n    if (!handler) {\n      throw new Error(`no handlers for embed type \"${embedType}\"`);\n    }\n    return handler;\n  }\n\n  ops: Op[];\n  constructor(ops?: Op[] | { ops: Op[] }) {\n    // Assume we are given a well formed ops\n    if (Array.isArray(ops)) {\n      this.ops = ops;\n    } else if (ops != null && Array.isArray(ops.ops)) {\n      this.ops = ops.ops;\n    } else {\n      this.ops = [];\n    }\n  }\n\n  insert(\n    arg: string | Record<string, unknown>,\n    attributes?: AttributeMap | null,\n  ): this {\n    const newOp: Op = {};\n    if (typeof arg === 'string' && arg.length === 0) {\n      return this;\n    }\n    newOp.insert = arg;\n    if (\n      attributes != null &&\n      typeof attributes === 'object' &&\n      Object.keys(attributes).length > 0\n    ) {\n      newOp.attributes = attributes;\n    }\n    return this.push(newOp);\n  }\n\n  delete(length: number): this {\n    if (length <= 0) {\n      return this;\n    }\n    return this.push({ delete: length });\n  }\n\n  retain(\n    length: number | Record<string, unknown>,\n    attributes?: AttributeMap | null,\n  ): this {\n    if (typeof length === 'number' && length <= 0) {\n      return this;\n    }\n    const newOp: Op = { retain: length };\n    if (\n      attributes != null &&\n      typeof attributes === 'object' &&\n      Object.keys(attributes).length > 0\n    ) {\n      newOp.attributes = attributes;\n    }\n    return this.push(newOp);\n  }\n\n  push(newOp: Op): this {\n    let index = this.ops.length;\n    let lastOp = this.ops[index - 1];\n    newOp = cloneDeep(newOp);\n    if (typeof lastOp === 'object') {\n      if (\n        typeof newOp.delete === 'number' &&\n        typeof lastOp.delete === 'number'\n      ) {\n        this.ops[index - 1] = { delete: lastOp.delete + newOp.delete };\n        return this;\n      }\n      // Since it does not matter if we insert before or after deleting at the same index,\n      // always prefer to insert first\n      if (typeof lastOp.delete === 'number' && newOp.insert != null) {\n        index -= 1;\n        lastOp = this.ops[index - 1];\n        if (typeof lastOp !== 'object') {\n          this.ops.unshift(newOp);\n          return this;\n        }\n      }\n      if (isEqual(newOp.attributes, lastOp.attributes)) {\n        if (\n          typeof newOp.insert === 'string' &&\n          typeof lastOp.insert === 'string'\n        ) {\n          this.ops[index - 1] = { insert: lastOp.insert + newOp.insert };\n          if (typeof newOp.attributes === 'object') {\n            this.ops[index - 1].attributes = newOp.attributes;\n          }\n          return this;\n        } else if (\n          typeof newOp.retain === 'number' &&\n          typeof lastOp.retain === 'number'\n        ) {\n          this.ops[index - 1] = { retain: lastOp.retain + newOp.retain };\n          if (typeof newOp.attributes === 'object') {\n            this.ops[index - 1].attributes = newOp.attributes;\n          }\n          return this;\n        }\n      }\n    }\n    if (index === this.ops.length) {\n      this.ops.push(newOp);\n    } else {\n      this.ops.splice(index, 0, newOp);\n    }\n    return this;\n  }\n\n  chop(): this {\n    const lastOp = this.ops[this.ops.length - 1];\n    if (lastOp && typeof lastOp.retain === 'number' && !lastOp.attributes) {\n      this.ops.pop();\n    }\n    return this;\n  }\n\n  filter(predicate: (op: Op, index: number) => boolean): Op[] {\n    return this.ops.filter(predicate);\n  }\n\n  forEach(predicate: (op: Op, index: number) => void): void {\n    this.ops.forEach(predicate);\n  }\n\n  map<T>(predicate: (op: Op, index: number) => T): T[] {\n    return this.ops.map(predicate);\n  }\n\n  partition(predicate: (op: Op) => boolean): [Op[], Op[]] {\n    const passed: Op[] = [];\n    const failed: Op[] = [];\n    this.forEach((op) => {\n      const target = predicate(op) ? passed : failed;\n      target.push(op);\n    });\n    return [passed, failed];\n  }\n\n  reduce<T>(\n    predicate: (accum: T, curr: Op, index: number) => T,\n    initialValue: T,\n  ): T {\n    return this.ops.reduce(predicate, initialValue);\n  }\n\n  changeLength(): number {\n    return this.reduce((length, elem) => {\n      if (elem.insert) {\n        return length + Op.length(elem);\n      } else if (elem.delete) {\n        return length - elem.delete;\n      }\n      return length;\n    }, 0);\n  }\n\n  length(): number {\n    return this.reduce((length, elem) => {\n      return length + Op.length(elem);\n    }, 0);\n  }\n\n  slice(start = 0, end = Infinity): Delta {\n    const ops = [];\n    const iter = new OpIterator(this.ops);\n    let index = 0;\n    while (index < end && iter.hasNext()) {\n      let nextOp;\n      if (index < start) {\n        nextOp = iter.next(start - index);\n      } else {\n        nextOp = iter.next(end - index);\n        ops.push(nextOp);\n      }\n      index += Op.length(nextOp);\n    }\n    return new Delta(ops);\n  }\n\n  compose(other: Delta): Delta {\n    const thisIter = new OpIterator(this.ops);\n    const otherIter = new OpIterator(other.ops);\n    const ops = [];\n    const firstOther = otherIter.peek();\n    if (\n      firstOther != null &&\n      typeof firstOther.retain === 'number' &&\n      firstOther.attributes == null\n    ) {\n      let firstLeft = firstOther.retain;\n      while (\n        thisIter.peekType() === 'insert' &&\n        thisIter.peekLength() <= firstLeft\n      ) {\n        firstLeft -= thisIter.peekLength();\n        ops.push(thisIter.next());\n      }\n      if (firstOther.retain - firstLeft > 0) {\n        otherIter.next(firstOther.retain - firstLeft);\n      }\n    }\n    const delta = new Delta(ops);\n    while (thisIter.hasNext() || otherIter.hasNext()) {\n      if (otherIter.peekType() === 'insert') {\n        delta.push(otherIter.next());\n      } else if (thisIter.peekType() === 'delete') {\n        delta.push(thisIter.next());\n      } else {\n        const length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n        const thisOp = thisIter.next(length);\n        const otherOp = otherIter.next(length);\n        if (otherOp.retain) {\n          const newOp: Op = {};\n          if (typeof thisOp.retain === 'number') {\n            newOp.retain =\n              typeof otherOp.retain === 'number' ? length : otherOp.retain;\n          } else {\n            if (typeof otherOp.retain === 'number') {\n              if (thisOp.retain == null) {\n                newOp.insert = thisOp.insert;\n              } else {\n                newOp.retain = thisOp.retain;\n              }\n            } else {\n              const action = thisOp.retain == null ? 'insert' : 'retain';\n              const [embedType, thisData, otherData] = getEmbedTypeAndData(\n                thisOp[action],\n                otherOp.retain,\n              );\n              const handler = Delta.getHandler(embedType);\n              newOp[action] = {\n                [embedType]: handler.compose(\n                  thisData,\n                  otherData,\n                  action === 'retain',\n                ),\n              };\n            }\n          }\n          // Preserve null when composing with a retain, otherwise remove it for inserts\n          const attributes = AttributeMap.compose(\n            thisOp.attributes,\n            otherOp.attributes,\n            typeof thisOp.retain === 'number',\n          );\n          if (attributes) {\n            newOp.attributes = attributes;\n          }\n          delta.push(newOp);\n\n          // Optimization if rest of other is just retain\n          if (\n            !otherIter.hasNext() &&\n            isEqual(delta.ops[delta.ops.length - 1], newOp)\n          ) {\n            const rest = new Delta(thisIter.rest());\n            return delta.concat(rest).chop();\n          }\n\n          // Other op should be delete, we could be an insert or retain\n          // Insert + delete cancels out\n        } else if (\n          typeof otherOp.delete === 'number' &&\n          (typeof thisOp.retain === 'number' ||\n            (typeof thisOp.retain === 'object' && thisOp.retain !== null))\n        ) {\n          delta.push(otherOp);\n        }\n      }\n    }\n    return delta.chop();\n  }\n\n  concat(other: Delta): Delta {\n    const delta = new Delta(this.ops.slice());\n    if (other.ops.length > 0) {\n      delta.push(other.ops[0]);\n      delta.ops = delta.ops.concat(other.ops.slice(1));\n    }\n    return delta;\n  }\n\n  diff(other: Delta, cursor?: number | diff.CursorInfo): Delta {\n    if (this.ops === other.ops) {\n      return new Delta();\n    }\n    const strings = [this, other].map((delta) => {\n      return delta\n        .map((op) => {\n          if (op.insert != null) {\n            return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER;\n          }\n          const prep = delta === other ? 'on' : 'with';\n          throw new Error('diff() called ' + prep + ' non-document');\n        })\n        .join('');\n    });\n    const retDelta = new Delta();\n    const diffResult = diff(strings[0], strings[1], cursor, true);\n    const thisIter = new OpIterator(this.ops);\n    const otherIter = new OpIterator(other.ops);\n    diffResult.forEach((component: diff.Diff) => {\n      let length = component[1].length;\n      while (length > 0) {\n        let opLength = 0;\n        switch (component[0]) {\n          case diff.INSERT:\n            opLength = Math.min(otherIter.peekLength(), length);\n            retDelta.push(otherIter.next(opLength));\n            break;\n          case diff.DELETE:\n            opLength = Math.min(length, thisIter.peekLength());\n            thisIter.next(opLength);\n            retDelta.delete(opLength);\n            break;\n          case diff.EQUAL:\n            opLength = Math.min(\n              thisIter.peekLength(),\n              otherIter.peekLength(),\n              length,\n            );\n            const thisOp = thisIter.next(opLength);\n            const otherOp = otherIter.next(opLength);\n            if (isEqual(thisOp.insert, otherOp.insert)) {\n              retDelta.retain(\n                opLength,\n                AttributeMap.diff(thisOp.attributes, otherOp.attributes),\n              );\n            } else {\n              retDelta.push(otherOp).delete(opLength);\n            }\n            break;\n        }\n        length -= opLength;\n      }\n    });\n    return retDelta.chop();\n  }\n\n  eachLine(\n    predicate: (\n      line: Delta,\n      attributes: AttributeMap,\n      index: number,\n    ) => boolean | void,\n    newline = '\\n',\n  ): void {\n    const iter = new OpIterator(this.ops);\n    let line = new Delta();\n    let i = 0;\n    while (iter.hasNext()) {\n      if (iter.peekType() !== 'insert') {\n        return;\n      }\n      const thisOp = iter.peek();\n      const start = Op.length(thisOp) - iter.peekLength();\n      const index =\n        typeof thisOp.insert === 'string'\n          ? thisOp.insert.indexOf(newline, start) - start\n          : -1;\n      if (index < 0) {\n        line.push(iter.next());\n      } else if (index > 0) {\n        line.push(iter.next(index));\n      } else {\n        if (predicate(line, iter.next(1).attributes || {}, i) === false) {\n          return;\n        }\n        i += 1;\n        line = new Delta();\n      }\n    }\n    if (line.length() > 0) {\n      predicate(line, {}, i);\n    }\n  }\n\n  invert(base: Delta): Delta {\n    const inverted = new Delta();\n    this.reduce((baseIndex, op) => {\n      if (op.insert) {\n        inverted.delete(Op.length(op));\n      } else if (typeof op.retain === 'number' && op.attributes == null) {\n        inverted.retain(op.retain);\n        return baseIndex + op.retain;\n      } else if (op.delete || typeof op.retain === 'number') {\n        const length = (op.delete || op.retain) as number;\n        const slice = base.slice(baseIndex, baseIndex + length);\n        slice.forEach((baseOp) => {\n          if (op.delete) {\n            inverted.push(baseOp);\n          } else if (op.retain && op.attributes) {\n            inverted.retain(\n              Op.length(baseOp),\n              AttributeMap.invert(op.attributes, baseOp.attributes),\n            );\n          }\n        });\n        return baseIndex + length;\n      } else if (typeof op.retain === 'object' && op.retain !== null) {\n        const slice = base.slice(baseIndex, baseIndex + 1);\n        const baseOp = new OpIterator(slice.ops).next();\n        const [embedType, opData, baseOpData] = getEmbedTypeAndData(\n          op.retain,\n          baseOp.insert,\n        );\n        const handler = Delta.getHandler(embedType);\n        inverted.retain(\n          { [embedType]: handler.invert(opData, baseOpData) },\n          AttributeMap.invert(op.attributes, baseOp.attributes),\n        );\n        return baseIndex + 1;\n      }\n      return baseIndex;\n    }, 0);\n    return inverted.chop();\n  }\n\n  transform(index: number, priority?: boolean): number;\n  transform(other: Delta, priority?: boolean): Delta;\n  transform(arg: number | Delta, priority = false): typeof arg {\n    priority = !!priority;\n    if (typeof arg === 'number') {\n      return this.transformPosition(arg, priority);\n    }\n    const other: Delta = arg;\n    const thisIter = new OpIterator(this.ops);\n    const otherIter = new OpIterator(other.ops);\n    const delta = new Delta();\n    while (thisIter.hasNext() || otherIter.hasNext()) {\n      if (\n        thisIter.peekType() === 'insert' &&\n        (priority || otherIter.peekType() !== 'insert')\n      ) {\n        delta.retain(Op.length(thisIter.next()));\n      } else if (otherIter.peekType() === 'insert') {\n        delta.push(otherIter.next());\n      } else {\n        const length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n        const thisOp = thisIter.next(length);\n        const otherOp = otherIter.next(length);\n        if (thisOp.delete) {\n          // Our delete either makes their delete redundant or removes their retain\n          continue;\n        } else if (otherOp.delete) {\n          delta.push(otherOp);\n        } else {\n          const thisData = thisOp.retain;\n          const otherData = otherOp.retain;\n          let transformedData: Op['retain'] =\n            typeof otherData === 'object' && otherData !== null\n              ? otherData\n              : length;\n          if (\n            typeof thisData === 'object' &&\n            thisData !== null &&\n            typeof otherData === 'object' &&\n            otherData !== null\n          ) {\n            const embedType = Object.keys(thisData)[0];\n            if (embedType === Object.keys(otherData)[0]) {\n              const handler = Delta.getHandler(embedType);\n              if (handler) {\n                transformedData = {\n                  [embedType]: handler.transform(\n                    thisData[embedType],\n                    otherData[embedType],\n                    priority,\n                  ),\n                };\n              }\n            }\n          }\n\n          // We retain either their retain or insert\n          delta.retain(\n            transformedData,\n            AttributeMap.transform(\n              thisOp.attributes,\n              otherOp.attributes,\n              priority,\n            ),\n          );\n        }\n      }\n    }\n    return delta.chop();\n  }\n\n  transformPosition(index: number, priority = false): number {\n    priority = !!priority;\n    const thisIter = new OpIterator(this.ops);\n    let offset = 0;\n    while (thisIter.hasNext() && offset <= index) {\n      const length = thisIter.peekLength();\n      const nextType = thisIter.peekType();\n      thisIter.next();\n      if (nextType === 'delete') {\n        index -= Math.min(length, index - offset);\n        continue;\n      } else if (nextType === 'insert' && (offset < index || !priority)) {\n        index += length;\n      }\n      offset += length;\n    }\n    return index;\n  }\n}\n\nexport default Delta;\n\nexport { Op, OpIterator, AttributeMap };\n\nif (typeof module === 'object') {\n  module.exports = Delta;\n  module.exports.default = Delta;\n}\n"],"mappings":";;;;;;AAAA,MAAAA,IAAA,GAAAC,OAAA;AACA,MAAAC,SAAA,GAAAD,OAAA;AACA,MAAAE,OAAA,GAAAF,OAAA;AACA,MAAAG,cAAA,GAAAH,OAAA;AAojByBI,OAAA,CAAAC,YAAA,GApjBlBF,cAAA,CAAAG,OAAY;AACnB,MAAAC,IAAA,GAAAP,OAAA;AAmjBSI,OAAA,CAAAI,EAAA,GAnjBFD,IAAA,CAAAD,OAAE;AACT,MAAAG,YAAA,GAAAT,OAAA;AAkjBaI,OAAA,CAAAM,UAAA,GAljBND,YAAA,CAAAH,OAAU;AAEjB,MAAMK,cAAc,GAAGC,MAAM,CAACC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;AAQ/C,MAAMC,mBAAmB,GAAGA,CAC1BC,CAA8B,EAC9BC,CAAe,KACe;EAC9B,IAAI,OAAOD,CAAC,KAAK,QAAQ,IAAIA,CAAC,KAAK,IAAI,EAAE;IACvC,MAAM,IAAIE,KAAK,CAAC,mBAAmB,OAAOF,CAAC,EAAE,CAAC;;EAEhD,IAAI,OAAOC,CAAC,KAAK,QAAQ,IAAIA,CAAC,KAAK,IAAI,EAAE;IACvC,MAAM,IAAIC,KAAK,CAAC,mBAAmB,OAAOD,CAAC,EAAE,CAAC;;EAEhD,MAAME,SAAS,GAAGC,MAAM,CAACC,IAAI,CAACL,CAAC,CAAC,CAAC,CAAC,CAAC;EACnC,IAAI,CAACG,SAAS,IAAIA,SAAS,KAAKC,MAAM,CAACC,IAAI,CAACJ,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;IACjD,MAAM,IAAIC,KAAK,CACb,4BAA4BC,SAAS,OAAOC,MAAM,CAACC,IAAI,CAACJ,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAChE;;EAEH,OAAO,CAACE,SAAS,EAAEH,CAAC,CAACG,SAAS,CAAC,EAAEF,CAAC,CAACE,SAAS,CAAC,CAAC;AAChD,CAAC;AAED,MAAMG,KAAK;EAuBTC,YAAYC,GAA0B;IACpC;IACA,IAAIC,KAAK,CAACC,OAAO,CAACF,GAAG,CAAC,EAAE;MACtB,IAAI,CAACA,GAAG,GAAGA,GAAG;KACf,MAAM,IAAIA,GAAG,IAAI,IAAI,IAAIC,KAAK,CAACC,OAAO,CAACF,GAAG,CAACA,GAAG,CAAC,EAAE;MAChD,IAAI,CAACA,GAAG,GAAGA,GAAG,CAACA,GAAG;KACnB,MAAM;MACL,IAAI,CAACA,GAAG,GAAG,EAAE;;EAEjB;EA1BA,OAAOG,aAAaA,CAAIR,SAAiB,EAAES,OAAwB;IACjE,IAAI,CAACC,QAAQ,CAACV,SAAS,CAAC,GAAGS,OAAO;EACpC;EAEA,OAAOE,eAAeA,CAACX,SAAiB;IACtC,OAAO,IAAI,CAACU,QAAQ,CAACV,SAAS,CAAC;EACjC;EAEQ,OAAOY,UAAUA,CAACZ,SAAiB;IACzC,MAAMS,OAAO,GAAG,IAAI,CAACC,QAAQ,CAACV,SAAS,CAAC;IACxC,IAAI,CAACS,OAAO,EAAE;MACZ,MAAM,IAAIV,KAAK,CAAC,+BAA+BC,SAAS,GAAG,CAAC;;IAE9D,OAAOS,OAAO;EAChB;EAcAI,MAAMA,CACJC,GAAqC,EACrCC,UAAgC;IAEhC,MAAMC,KAAK,GAAO,EAAE;IACpB,IAAI,OAAOF,GAAG,KAAK,QAAQ,IAAIA,GAAG,CAACG,MAAM,KAAK,CAAC,EAAE;MAC/C,OAAO,IAAI;;IAEbD,KAAK,CAACH,MAAM,GAAGC,GAAG;IAClB,IACEC,UAAU,IAAI,IAAI,IAClB,OAAOA,UAAU,KAAK,QAAQ,IAC9Bd,MAAM,CAACC,IAAI,CAACa,UAAU,CAAC,CAACE,MAAM,GAAG,CAAC,EAClC;MACAD,KAAK,CAACD,UAAU,GAAGA,UAAU;;IAE/B,OAAO,IAAI,CAACG,IAAI,CAACF,KAAK,CAAC;EACzB;EAEAG,MAAMA,CAACF,MAAc;IACnB,IAAIA,MAAM,IAAI,CAAC,EAAE;MACf,OAAO,IAAI;;IAEb,OAAO,IAAI,CAACC,IAAI,CAAC;MAAEC,MAAM,EAAEF;IAAM,CAAE,CAAC;EACtC;EAEAG,MAAMA,CACJH,MAAwC,EACxCF,UAAgC;IAEhC,IAAI,OAAOE,MAAM,KAAK,QAAQ,IAAIA,MAAM,IAAI,CAAC,EAAE;MAC7C,OAAO,IAAI;;IAEb,MAAMD,KAAK,GAAO;MAAEI,MAAM,EAAEH;IAAM,CAAE;IACpC,IACEF,UAAU,IAAI,IAAI,IAClB,OAAOA,UAAU,KAAK,QAAQ,IAC9Bd,MAAM,CAACC,IAAI,CAACa,UAAU,CAAC,CAACE,MAAM,GAAG,CAAC,EAClC;MACAD,KAAK,CAACD,UAAU,GAAGA,UAAU;;IAE/B,OAAO,IAAI,CAACG,IAAI,CAACF,KAAK,CAAC;EACzB;EAEAE,IAAIA,CAACF,KAAS;IACZ,IAAIK,KAAK,GAAG,IAAI,CAAChB,GAAG,CAACY,MAAM;IAC3B,IAAIK,MAAM,GAAG,IAAI,CAACjB,GAAG,CAACgB,KAAK,GAAG,CAAC,CAAC;IAChCL,KAAK,GAAGjC,SAAS,CAACiC,KAAK,CAAC;IACxB,IAAI,OAAOM,MAAM,KAAK,QAAQ,EAAE;MAC9B,IACE,OAAON,KAAK,CAACG,MAAM,KAAK,QAAQ,IAChC,OAAOG,MAAM,CAACH,MAAM,KAAK,QAAQ,EACjC;QACA,IAAI,CAACd,GAAG,CAACgB,KAAK,GAAG,CAAC,CAAC,GAAG;UAAEF,MAAM,EAAEG,MAAM,CAACH,MAAM,GAAGH,KAAK,CAACG;QAAM,CAAE;QAC9D,OAAO,IAAI;;MAEb;MACA;MACA,IAAI,OAAOG,MAAM,CAACH,MAAM,KAAK,QAAQ,IAAIH,KAAK,CAACH,MAAM,IAAI,IAAI,EAAE;QAC7DQ,KAAK,IAAI,CAAC;QACVC,MAAM,GAAG,IAAI,CAACjB,GAAG,CAACgB,KAAK,GAAG,CAAC,CAAC;QAC5B,IAAI,OAAOC,MAAM,KAAK,QAAQ,EAAE;UAC9B,IAAI,CAACjB,GAAG,CAACkB,OAAO,CAACP,KAAK,CAAC;UACvB,OAAO,IAAI;;;MAGf,IAAIhC,OAAO,CAACgC,KAAK,CAACD,UAAU,EAAEO,MAAM,CAACP,UAAU,CAAC,EAAE;QAChD,IACE,OAAOC,KAAK,CAACH,MAAM,KAAK,QAAQ,IAChC,OAAOS,MAAM,CAACT,MAAM,KAAK,QAAQ,EACjC;UACA,IAAI,CAACR,GAAG,CAACgB,KAAK,GAAG,CAAC,CAAC,GAAG;YAAER,MAAM,EAAES,MAAM,CAACT,MAAM,GAAGG,KAAK,CAACH;UAAM,CAAE;UAC9D,IAAI,OAAOG,KAAK,CAACD,UAAU,KAAK,QAAQ,EAAE;YACxC,IAAI,CAACV,GAAG,CAACgB,KAAK,GAAG,CAAC,CAAC,CAACN,UAAU,GAAGC,KAAK,CAACD,UAAU;;UAEnD,OAAO,IAAI;SACZ,MAAM,IACL,OAAOC,KAAK,CAACI,MAAM,KAAK,QAAQ,IAChC,OAAOE,MAAM,CAACF,MAAM,KAAK,QAAQ,EACjC;UACA,IAAI,CAACf,GAAG,CAACgB,KAAK,GAAG,CAAC,CAAC,GAAG;YAAED,MAAM,EAAEE,MAAM,CAACF,MAAM,GAAGJ,KAAK,CAACI;UAAM,CAAE;UAC9D,IAAI,OAAOJ,KAAK,CAACD,UAAU,KAAK,QAAQ,EAAE;YACxC,IAAI,CAACV,GAAG,CAACgB,KAAK,GAAG,CAAC,CAAC,CAACN,UAAU,GAAGC,KAAK,CAACD,UAAU;;UAEnD,OAAO,IAAI;;;;IAIjB,IAAIM,KAAK,KAAK,IAAI,CAAChB,GAAG,CAACY,MAAM,EAAE;MAC7B,IAAI,CAACZ,GAAG,CAACa,IAAI,CAACF,KAAK,CAAC;KACrB,MAAM;MACL,IAAI,CAACX,GAAG,CAACmB,MAAM,CAACH,KAAK,EAAE,CAAC,EAAEL,KAAK,CAAC;;IAElC,OAAO,IAAI;EACb;EAEAS,IAAIA,CAAA;IACF,MAAMH,MAAM,GAAG,IAAI,CAACjB,GAAG,CAAC,IAAI,CAACA,GAAG,CAACY,MAAM,GAAG,CAAC,CAAC;IAC5C,IAAIK,MAAM,IAAI,OAAOA,MAAM,CAACF,MAAM,KAAK,QAAQ,IAAI,CAACE,MAAM,CAACP,UAAU,EAAE;MACrE,IAAI,CAACV,GAAG,CAACqB,GAAG,EAAE;;IAEhB,OAAO,IAAI;EACb;EAEAC,MAAMA,CAACC,SAA6C;IAClD,OAAO,IAAI,CAACvB,GAAG,CAACsB,MAAM,CAACC,SAAS,CAAC;EACnC;EAEAC,OAAOA,CAACD,SAA0C;IAChD,IAAI,CAACvB,GAAG,CAACwB,OAAO,CAACD,SAAS,CAAC;EAC7B;EAEAE,GAAGA,CAAIF,SAAuC;IAC5C,OAAO,IAAI,CAACvB,GAAG,CAACyB,GAAG,CAACF,SAAS,CAAC;EAChC;EAEAG,SAASA,CAACH,SAA8B;IACtC,MAAMI,MAAM,GAAS,EAAE;IACvB,MAAMC,MAAM,GAAS,EAAE;IACvB,IAAI,CAACJ,OAAO,CAAEK,EAAE,IAAI;MAClB,MAAMC,MAAM,GAAGP,SAAS,CAACM,EAAE,CAAC,GAAGF,MAAM,GAAGC,MAAM;MAC9CE,MAAM,CAACjB,IAAI,CAACgB,EAAE,CAAC;IACjB,CAAC,CAAC;IACF,OAAO,CAACF,MAAM,EAAEC,MAAM,CAAC;EACzB;EAEAG,MAAMA,CACJR,SAAmD,EACnDS,YAAe;IAEf,OAAO,IAAI,CAAChC,GAAG,CAAC+B,MAAM,CAACR,SAAS,EAAES,YAAY,CAAC;EACjD;EAEAC,YAAYA,CAAA;IACV,OAAO,IAAI,CAACF,MAAM,CAAC,CAACnB,MAAM,EAAEsB,IAAI,KAAI;MAClC,IAAIA,IAAI,CAAC1B,MAAM,EAAE;QACf,OAAOI,MAAM,GAAG5B,IAAA,CAAAD,OAAE,CAAC6B,MAAM,CAACsB,IAAI,CAAC;OAChC,MAAM,IAAIA,IAAI,CAACpB,MAAM,EAAE;QACtB,OAAOF,MAAM,GAAGsB,IAAI,CAACpB,MAAM;;MAE7B,OAAOF,MAAM;IACf,CAAC,EAAE,CAAC,CAAC;EACP;EAEAA,MAAMA,CAAA;IACJ,OAAO,IAAI,CAACmB,MAAM,CAAC,CAACnB,MAAM,EAAEsB,IAAI,KAAI;MAClC,OAAOtB,MAAM,GAAG5B,IAAA,CAAAD,OAAE,CAAC6B,MAAM,CAACsB,IAAI,CAAC;IACjC,CAAC,EAAE,CAAC,CAAC;EACP;EAEAC,KAAKA,CAACC,KAAK,GAAG,CAAC,EAAEC,GAAG,GAAGC,QAAQ;IAC7B,MAAMtC,GAAG,GAAG,EAAE;IACd,MAAMuC,IAAI,GAAG,IAAIrD,YAAA,CAAAH,OAAU,CAAC,IAAI,CAACiB,GAAG,CAAC;IACrC,IAAIgB,KAAK,GAAG,CAAC;IACb,OAAOA,KAAK,GAAGqB,GAAG,IAAIE,IAAI,CAACC,OAAO,EAAE,EAAE;MACpC,IAAIC,MAAM;MACV,IAAIzB,KAAK,GAAGoB,KAAK,EAAE;QACjBK,MAAM,GAAGF,IAAI,CAACG,IAAI,CAACN,KAAK,GAAGpB,KAAK,CAAC;OAClC,MAAM;QACLyB,MAAM,GAAGF,IAAI,CAACG,IAAI,CAACL,GAAG,GAAGrB,KAAK,CAAC;QAC/BhB,GAAG,CAACa,IAAI,CAAC4B,MAAM,CAAC;;MAElBzB,KAAK,IAAIhC,IAAA,CAAAD,OAAE,CAAC6B,MAAM,CAAC6B,MAAM,CAAC;;IAE5B,OAAO,IAAI3C,KAAK,CAACE,GAAG,CAAC;EACvB;EAEA2C,OAAOA,CAACC,KAAY;IAClB,MAAMC,QAAQ,GAAG,IAAI3D,YAAA,CAAAH,OAAU,CAAC,IAAI,CAACiB,GAAG,CAAC;IACzC,MAAM8C,SAAS,GAAG,IAAI5D,YAAA,CAAAH,OAAU,CAAC6D,KAAK,CAAC5C,GAAG,CAAC;IAC3C,MAAMA,GAAG,GAAG,EAAE;IACd,MAAM+C,UAAU,GAAGD,SAAS,CAACE,IAAI,EAAE;IACnC,IACED,UAAU,IAAI,IAAI,IAClB,OAAOA,UAAU,CAAChC,MAAM,KAAK,QAAQ,IACrCgC,UAAU,CAACrC,UAAU,IAAI,IAAI,EAC7B;MACA,IAAIuC,SAAS,GAAGF,UAAU,CAAChC,MAAM;MACjC,OACE8B,QAAQ,CAACK,QAAQ,EAAE,KAAK,QAAQ,IAChCL,QAAQ,CAACM,UAAU,EAAE,IAAIF,SAAS,EAClC;QACAA,SAAS,IAAIJ,QAAQ,CAACM,UAAU,EAAE;QAClCnD,GAAG,CAACa,IAAI,CAACgC,QAAQ,CAACH,IAAI,EAAE,CAAC;;MAE3B,IAAIK,UAAU,CAAChC,MAAM,GAAGkC,SAAS,GAAG,CAAC,EAAE;QACrCH,SAAS,CAACJ,IAAI,CAACK,UAAU,CAAChC,MAAM,GAAGkC,SAAS,CAAC;;;IAGjD,MAAMG,KAAK,GAAG,IAAItD,KAAK,CAACE,GAAG,CAAC;IAC5B,OAAO6C,QAAQ,CAACL,OAAO,EAAE,IAAIM,SAAS,CAACN,OAAO,EAAE,EAAE;MAChD,IAAIM,SAAS,CAACI,QAAQ,EAAE,KAAK,QAAQ,EAAE;QACrCE,KAAK,CAACvC,IAAI,CAACiC,SAAS,CAACJ,IAAI,EAAE,CAAC;OAC7B,MAAM,IAAIG,QAAQ,CAACK,QAAQ,EAAE,KAAK,QAAQ,EAAE;QAC3CE,KAAK,CAACvC,IAAI,CAACgC,QAAQ,CAACH,IAAI,EAAE,CAAC;OAC5B,MAAM;QACL,MAAM9B,MAAM,GAAGyC,IAAI,CAACC,GAAG,CAACT,QAAQ,CAACM,UAAU,EAAE,EAAEL,SAAS,CAACK,UAAU,EAAE,CAAC;QACtE,MAAMI,MAAM,GAAGV,QAAQ,CAACH,IAAI,CAAC9B,MAAM,CAAC;QACpC,MAAM4C,OAAO,GAAGV,SAAS,CAACJ,IAAI,CAAC9B,MAAM,CAAC;QACtC,IAAI4C,OAAO,CAACzC,MAAM,EAAE;UAClB,MAAMJ,KAAK,GAAO,EAAE;UACpB,IAAI,OAAO4C,MAAM,CAACxC,MAAM,KAAK,QAAQ,EAAE;YACrCJ,KAAK,CAACI,MAAM,GACV,OAAOyC,OAAO,CAACzC,MAAM,KAAK,QAAQ,GAAGH,MAAM,GAAG4C,OAAO,CAACzC,MAAM;WAC/D,MAAM;YACL,IAAI,OAAOyC,OAAO,CAACzC,MAAM,KAAK,QAAQ,EAAE;cACtC,IAAIwC,MAAM,CAACxC,MAAM,IAAI,IAAI,EAAE;gBACzBJ,KAAK,CAACH,MAAM,GAAG+C,MAAM,CAAC/C,MAAM;eAC7B,MAAM;gBACLG,KAAK,CAACI,MAAM,GAAGwC,MAAM,CAACxC,MAAM;;aAE/B,MAAM;cACL,MAAM0C,MAAM,GAAGF,MAAM,CAACxC,MAAM,IAAI,IAAI,GAAG,QAAQ,GAAG,QAAQ;cAC1D,MAAM,CAACpB,SAAS,EAAE+D,QAAQ,EAAEC,SAAS,CAAC,GAAGpE,mBAAmB,CAC1DgE,MAAM,CAACE,MAAM,CAAC,EACdD,OAAO,CAACzC,MAAM,CACf;cACD,MAAMX,OAAO,GAAGN,KAAK,CAACS,UAAU,CAACZ,SAAS,CAAC;cAC3CgB,KAAK,CAAC8C,MAAM,CAAC,GAAG;gBACd,CAAC9D,SAAS,GAAGS,OAAO,CAACuC,OAAO,CAC1Be,QAAQ,EACRC,SAAS,EACTF,MAAM,KAAK,QAAQ;eAEtB;;;UAGL;UACA,MAAM/C,UAAU,GAAG9B,cAAA,CAAAG,OAAY,CAAC4D,OAAO,CACrCY,MAAM,CAAC7C,UAAU,EACjB8C,OAAO,CAAC9C,UAAU,EAClB,OAAO6C,MAAM,CAACxC,MAAM,KAAK,QAAQ,CAClC;UACD,IAAIL,UAAU,EAAE;YACdC,KAAK,CAACD,UAAU,GAAGA,UAAU;;UAE/B0C,KAAK,CAACvC,IAAI,CAACF,KAAK,CAAC;UAEjB;UACA,IACE,CAACmC,SAAS,CAACN,OAAO,EAAE,IACpB7D,OAAO,CAACyE,KAAK,CAACpD,GAAG,CAACoD,KAAK,CAACpD,GAAG,CAACY,MAAM,GAAG,CAAC,CAAC,EAAED,KAAK,CAAC,EAC/C;YACA,MAAMiD,IAAI,GAAG,IAAI9D,KAAK,CAAC+C,QAAQ,CAACe,IAAI,EAAE,CAAC;YACvC,OAAOR,KAAK,CAACS,MAAM,CAACD,IAAI,CAAC,CAACxC,IAAI,EAAE;;UAGlC;UACA;SACD,MAAM,IACL,OAAOoC,OAAO,CAAC1C,MAAM,KAAK,QAAQ,KACjC,OAAOyC,MAAM,CAACxC,MAAM,KAAK,QAAQ,IAC/B,OAAOwC,MAAM,CAACxC,MAAM,KAAK,QAAQ,IAAIwC,MAAM,CAACxC,MAAM,KAAK,IAAK,CAAC,EAChE;UACAqC,KAAK,CAACvC,IAAI,CAAC2C,OAAO,CAAC;;;;IAIzB,OAAOJ,KAAK,CAAChC,IAAI,EAAE;EACrB;EAEAyC,MAAMA,CAACjB,KAAY;IACjB,MAAMQ,KAAK,GAAG,IAAItD,KAAK,CAAC,IAAI,CAACE,GAAG,CAACmC,KAAK,EAAE,CAAC;IACzC,IAAIS,KAAK,CAAC5C,GAAG,CAACY,MAAM,GAAG,CAAC,EAAE;MACxBwC,KAAK,CAACvC,IAAI,CAAC+B,KAAK,CAAC5C,GAAG,CAAC,CAAC,CAAC,CAAC;MACxBoD,KAAK,CAACpD,GAAG,GAAGoD,KAAK,CAACpD,GAAG,CAAC6D,MAAM,CAACjB,KAAK,CAAC5C,GAAG,CAACmC,KAAK,CAAC,CAAC,CAAC,CAAC;;IAElD,OAAOiB,KAAK;EACd;EAEA5E,IAAIA,CAACoE,KAAY,EAAEkB,MAAiC;IAClD,IAAI,IAAI,CAAC9D,GAAG,KAAK4C,KAAK,CAAC5C,GAAG,EAAE;MAC1B,OAAO,IAAIF,KAAK,EAAE;;IAEpB,MAAMiE,OAAO,GAAG,CAAC,IAAI,EAAEnB,KAAK,CAAC,CAACnB,GAAG,CAAE2B,KAAK,IAAI;MAC1C,OAAOA,KAAK,CACT3B,GAAG,CAAEI,EAAE,IAAI;QACV,IAAIA,EAAE,CAACrB,MAAM,IAAI,IAAI,EAAE;UACrB,OAAO,OAAOqB,EAAE,CAACrB,MAAM,KAAK,QAAQ,GAAGqB,EAAE,CAACrB,MAAM,GAAGpB,cAAc;;QAEnE,MAAM4E,IAAI,GAAGZ,KAAK,KAAKR,KAAK,GAAG,IAAI,GAAG,MAAM;QAC5C,MAAM,IAAIlD,KAAK,CAAC,gBAAgB,GAAGsE,IAAI,GAAG,eAAe,CAAC;MAC5D,CAAC,CAAC,CACDC,IAAI,CAAC,EAAE,CAAC;IACb,CAAC,CAAC;IACF,MAAMC,QAAQ,GAAG,IAAIpE,KAAK,EAAE;IAC5B,MAAMqE,UAAU,GAAG3F,IAAI,CAACuF,OAAO,CAAC,CAAC,CAAC,EAAEA,OAAO,CAAC,CAAC,CAAC,EAAED,MAAM,EAAE,IAAI,CAAC;IAC7D,MAAMjB,QAAQ,GAAG,IAAI3D,YAAA,CAAAH,OAAU,CAAC,IAAI,CAACiB,GAAG,CAAC;IACzC,MAAM8C,SAAS,GAAG,IAAI5D,YAAA,CAAAH,OAAU,CAAC6D,KAAK,CAAC5C,GAAG,CAAC;IAC3CmE,UAAU,CAAC3C,OAAO,CAAE4C,SAAoB,IAAI;MAC1C,IAAIxD,MAAM,GAAGwD,SAAS,CAAC,CAAC,CAAC,CAACxD,MAAM;MAChC,OAAOA,MAAM,GAAG,CAAC,EAAE;QACjB,IAAIyD,QAAQ,GAAG,CAAC;QAChB,QAAQD,SAAS,CAAC,CAAC,CAAC;UAClB,KAAK5F,IAAI,CAAC8F,MAAM;YACdD,QAAQ,GAAGhB,IAAI,CAACC,GAAG,CAACR,SAAS,CAACK,UAAU,EAAE,EAAEvC,MAAM,CAAC;YACnDsD,QAAQ,CAACrD,IAAI,CAACiC,SAAS,CAACJ,IAAI,CAAC2B,QAAQ,CAAC,CAAC;YACvC;UACF,KAAK7F,IAAI,CAAC+F,MAAM;YACdF,QAAQ,GAAGhB,IAAI,CAACC,GAAG,CAAC1C,MAAM,EAAEiC,QAAQ,CAACM,UAAU,EAAE,CAAC;YAClDN,QAAQ,CAACH,IAAI,CAAC2B,QAAQ,CAAC;YACvBH,QAAQ,CAACpD,MAAM,CAACuD,QAAQ,CAAC;YACzB;UACF,KAAK7F,IAAI,CAACgG,KAAK;YACbH,QAAQ,GAAGhB,IAAI,CAACC,GAAG,CACjBT,QAAQ,CAACM,UAAU,EAAE,EACrBL,SAAS,CAACK,UAAU,EAAE,EACtBvC,MAAM,CACP;YACD,MAAM2C,MAAM,GAAGV,QAAQ,CAACH,IAAI,CAAC2B,QAAQ,CAAC;YACtC,MAAMb,OAAO,GAAGV,SAAS,CAACJ,IAAI,CAAC2B,QAAQ,CAAC;YACxC,IAAI1F,OAAO,CAAC4E,MAAM,CAAC/C,MAAM,EAAEgD,OAAO,CAAChD,MAAM,CAAC,EAAE;cAC1C0D,QAAQ,CAACnD,MAAM,CACbsD,QAAQ,EACRzF,cAAA,CAAAG,OAAY,CAACP,IAAI,CAAC+E,MAAM,CAAC7C,UAAU,EAAE8C,OAAO,CAAC9C,UAAU,CAAC,CACzD;aACF,MAAM;cACLwD,QAAQ,CAACrD,IAAI,CAAC2C,OAAO,CAAC,CAAC1C,MAAM,CAACuD,QAAQ,CAAC;;YAEzC;;QAEJzD,MAAM,IAAIyD,QAAQ;;IAEtB,CAAC,CAAC;IACF,OAAOH,QAAQ,CAAC9C,IAAI,EAAE;EACxB;EAEAqD,QAAQA,CACNlD,SAImB,EACnBmD,OAAO,GAAG,IAAI;IAEd,MAAMnC,IAAI,GAAG,IAAIrD,YAAA,CAAAH,OAAU,CAAC,IAAI,CAACiB,GAAG,CAAC;IACrC,IAAI2E,IAAI,GAAG,IAAI7E,KAAK,EAAE;IACtB,IAAI8E,CAAC,GAAG,CAAC;IACT,OAAOrC,IAAI,CAACC,OAAO,EAAE,EAAE;MACrB,IAAID,IAAI,CAACW,QAAQ,EAAE,KAAK,QAAQ,EAAE;QAChC;;MAEF,MAAMK,MAAM,GAAGhB,IAAI,CAACS,IAAI,EAAE;MAC1B,MAAMZ,KAAK,GAAGpD,IAAA,CAAAD,OAAE,CAAC6B,MAAM,CAAC2C,MAAM,CAAC,GAAGhB,IAAI,CAACY,UAAU,EAAE;MACnD,MAAMnC,KAAK,GACT,OAAOuC,MAAM,CAAC/C,MAAM,KAAK,QAAQ,GAC7B+C,MAAM,CAAC/C,MAAM,CAACqE,OAAO,CAACH,OAAO,EAAEtC,KAAK,CAAC,GAAGA,KAAK,GAC7C,CAAC,CAAC;MACR,IAAIpB,KAAK,GAAG,CAAC,EAAE;QACb2D,IAAI,CAAC9D,IAAI,CAAC0B,IAAI,CAACG,IAAI,EAAE,CAAC;OACvB,MAAM,IAAI1B,KAAK,GAAG,CAAC,EAAE;QACpB2D,IAAI,CAAC9D,IAAI,CAAC0B,IAAI,CAACG,IAAI,CAAC1B,KAAK,CAAC,CAAC;OAC5B,MAAM;QACL,IAAIO,SAAS,CAACoD,IAAI,EAAEpC,IAAI,CAACG,IAAI,CAAC,CAAC,CAAC,CAAChC,UAAU,IAAI,EAAE,EAAEkE,CAAC,CAAC,KAAK,KAAK,EAAE;UAC/D;;QAEFA,CAAC,IAAI,CAAC;QACND,IAAI,GAAG,IAAI7E,KAAK,EAAE;;;IAGtB,IAAI6E,IAAI,CAAC/D,MAAM,EAAE,GAAG,CAAC,EAAE;MACrBW,SAAS,CAACoD,IAAI,EAAE,EAAE,EAAEC,CAAC,CAAC;;EAE1B;EAEAE,MAAMA,CAACC,IAAW;IAChB,MAAMC,QAAQ,GAAG,IAAIlF,KAAK,EAAE;IAC5B,IAAI,CAACiC,MAAM,CAAC,CAACkD,SAAS,EAAEpD,EAAE,KAAI;MAC5B,IAAIA,EAAE,CAACrB,MAAM,EAAE;QACbwE,QAAQ,CAAClE,MAAM,CAAC9B,IAAA,CAAAD,OAAE,CAAC6B,MAAM,CAACiB,EAAE,CAAC,CAAC;OAC/B,MAAM,IAAI,OAAOA,EAAE,CAACd,MAAM,KAAK,QAAQ,IAAIc,EAAE,CAACnB,UAAU,IAAI,IAAI,EAAE;QACjEsE,QAAQ,CAACjE,MAAM,CAACc,EAAE,CAACd,MAAM,CAAC;QAC1B,OAAOkE,SAAS,GAAGpD,EAAE,CAACd,MAAM;OAC7B,MAAM,IAAIc,EAAE,CAACf,MAAM,IAAI,OAAOe,EAAE,CAACd,MAAM,KAAK,QAAQ,EAAE;QACrD,MAAMH,MAAM,GAAIiB,EAAE,CAACf,MAAM,IAAIe,EAAE,CAACd,MAAiB;QACjD,MAAMoB,KAAK,GAAG4C,IAAI,CAAC5C,KAAK,CAAC8C,SAAS,EAAEA,SAAS,GAAGrE,MAAM,CAAC;QACvDuB,KAAK,CAACX,OAAO,CAAE0D,MAAM,IAAI;UACvB,IAAIrD,EAAE,CAACf,MAAM,EAAE;YACbkE,QAAQ,CAACnE,IAAI,CAACqE,MAAM,CAAC;WACtB,MAAM,IAAIrD,EAAE,CAACd,MAAM,IAAIc,EAAE,CAACnB,UAAU,EAAE;YACrCsE,QAAQ,CAACjE,MAAM,CACb/B,IAAA,CAAAD,OAAE,CAAC6B,MAAM,CAACsE,MAAM,CAAC,EACjBtG,cAAA,CAAAG,OAAY,CAAC+F,MAAM,CAACjD,EAAE,CAACnB,UAAU,EAAEwE,MAAM,CAACxE,UAAU,CAAC,CACtD;;QAEL,CAAC,CAAC;QACF,OAAOuE,SAAS,GAAGrE,MAAM;OAC1B,MAAM,IAAI,OAAOiB,EAAE,CAACd,MAAM,KAAK,QAAQ,IAAIc,EAAE,CAACd,MAAM,KAAK,IAAI,EAAE;QAC9D,MAAMoB,KAAK,GAAG4C,IAAI,CAAC5C,KAAK,CAAC8C,SAAS,EAAEA,SAAS,GAAG,CAAC,CAAC;QAClD,MAAMC,MAAM,GAAG,IAAIhG,YAAA,CAAAH,OAAU,CAACoD,KAAK,CAACnC,GAAG,CAAC,CAAC0C,IAAI,EAAE;QAC/C,MAAM,CAAC/C,SAAS,EAAEwF,MAAM,EAAEC,UAAU,CAAC,GAAG7F,mBAAmB,CACzDsC,EAAE,CAACd,MAAM,EACTmE,MAAM,CAAC1E,MAAM,CACd;QACD,MAAMJ,OAAO,GAAGN,KAAK,CAACS,UAAU,CAACZ,SAAS,CAAC;QAC3CqF,QAAQ,CAACjE,MAAM,CACb;UAAE,CAACpB,SAAS,GAAGS,OAAO,CAAC0E,MAAM,CAACK,MAAM,EAAEC,UAAU;QAAC,CAAE,EACnDxG,cAAA,CAAAG,OAAY,CAAC+F,MAAM,CAACjD,EAAE,CAACnB,UAAU,EAAEwE,MAAM,CAACxE,UAAU,CAAC,CACtD;QACD,OAAOuE,SAAS,GAAG,CAAC;;MAEtB,OAAOA,SAAS;IAClB,CAAC,EAAE,CAAC,CAAC;IACL,OAAOD,QAAQ,CAAC5D,IAAI,EAAE;EACxB;EAIAiE,SAASA,CAAC5E,GAAmB,EAAE6E,QAAQ,GAAG,KAAK;IAC7CA,QAAQ,GAAG,CAAC,CAACA,QAAQ;IACrB,IAAI,OAAO7E,GAAG,KAAK,QAAQ,EAAE;MAC3B,OAAO,IAAI,CAAC8E,iBAAiB,CAAC9E,GAAG,EAAE6E,QAAQ,CAAC;;IAE9C,MAAM1C,KAAK,GAAUnC,GAAG;IACxB,MAAMoC,QAAQ,GAAG,IAAI3D,YAAA,CAAAH,OAAU,CAAC,IAAI,CAACiB,GAAG,CAAC;IACzC,MAAM8C,SAAS,GAAG,IAAI5D,YAAA,CAAAH,OAAU,CAAC6D,KAAK,CAAC5C,GAAG,CAAC;IAC3C,MAAMoD,KAAK,GAAG,IAAItD,KAAK,EAAE;IACzB,OAAO+C,QAAQ,CAACL,OAAO,EAAE,IAAIM,SAAS,CAACN,OAAO,EAAE,EAAE;MAChD,IACEK,QAAQ,CAACK,QAAQ,EAAE,KAAK,QAAQ,KAC/BoC,QAAQ,IAAIxC,SAAS,CAACI,QAAQ,EAAE,KAAK,QAAQ,CAAC,EAC/C;QACAE,KAAK,CAACrC,MAAM,CAAC/B,IAAA,CAAAD,OAAE,CAAC6B,MAAM,CAACiC,QAAQ,CAACH,IAAI,EAAE,CAAC,CAAC;OACzC,MAAM,IAAII,SAAS,CAACI,QAAQ,EAAE,KAAK,QAAQ,EAAE;QAC5CE,KAAK,CAACvC,IAAI,CAACiC,SAAS,CAACJ,IAAI,EAAE,CAAC;OAC7B,MAAM;QACL,MAAM9B,MAAM,GAAGyC,IAAI,CAACC,GAAG,CAACT,QAAQ,CAACM,UAAU,EAAE,EAAEL,SAAS,CAACK,UAAU,EAAE,CAAC;QACtE,MAAMI,MAAM,GAAGV,QAAQ,CAACH,IAAI,CAAC9B,MAAM,CAAC;QACpC,MAAM4C,OAAO,GAAGV,SAAS,CAACJ,IAAI,CAAC9B,MAAM,CAAC;QACtC,IAAI2C,MAAM,CAACzC,MAAM,EAAE;UACjB;UACA;SACD,MAAM,IAAI0C,OAAO,CAAC1C,MAAM,EAAE;UACzBsC,KAAK,CAACvC,IAAI,CAAC2C,OAAO,CAAC;SACpB,MAAM;UACL,MAAME,QAAQ,GAAGH,MAAM,CAACxC,MAAM;UAC9B,MAAM4C,SAAS,GAAGH,OAAO,CAACzC,MAAM;UAChC,IAAIyE,eAAe,GACjB,OAAO7B,SAAS,KAAK,QAAQ,IAAIA,SAAS,KAAK,IAAI,GAC/CA,SAAS,GACT/C,MAAM;UACZ,IACE,OAAO8C,QAAQ,KAAK,QAAQ,IAC5BA,QAAQ,KAAK,IAAI,IACjB,OAAOC,SAAS,KAAK,QAAQ,IAC7BA,SAAS,KAAK,IAAI,EAClB;YACA,MAAMhE,SAAS,GAAGC,MAAM,CAACC,IAAI,CAAC6D,QAAQ,CAAC,CAAC,CAAC,CAAC;YAC1C,IAAI/D,SAAS,KAAKC,MAAM,CAACC,IAAI,CAAC8D,SAAS,CAAC,CAAC,CAAC,CAAC,EAAE;cAC3C,MAAMvD,OAAO,GAAGN,KAAK,CAACS,UAAU,CAACZ,SAAS,CAAC;cAC3C,IAAIS,OAAO,EAAE;gBACXoF,eAAe,GAAG;kBAChB,CAAC7F,SAAS,GAAGS,OAAO,CAACiF,SAAS,CAC5B3B,QAAQ,CAAC/D,SAAS,CAAC,EACnBgE,SAAS,CAAChE,SAAS,CAAC,EACpB2F,QAAQ;iBAEX;;;;UAKP;UACAlC,KAAK,CAACrC,MAAM,CACVyE,eAAe,EACf5G,cAAA,CAAAG,OAAY,CAACsG,SAAS,CACpB9B,MAAM,CAAC7C,UAAU,EACjB8C,OAAO,CAAC9C,UAAU,EAClB4E,QAAQ,CACT,CACF;;;;IAIP,OAAOlC,KAAK,CAAChC,IAAI,EAAE;EACrB;EAEAmE,iBAAiBA,CAACvE,KAAa,EAAEsE,QAAQ,GAAG,KAAK;IAC/CA,QAAQ,GAAG,CAAC,CAACA,QAAQ;IACrB,MAAMzC,QAAQ,GAAG,IAAI3D,YAAA,CAAAH,OAAU,CAAC,IAAI,CAACiB,GAAG,CAAC;IACzC,IAAIyF,MAAM,GAAG,CAAC;IACd,OAAO5C,QAAQ,CAACL,OAAO,EAAE,IAAIiD,MAAM,IAAIzE,KAAK,EAAE;MAC5C,MAAMJ,MAAM,GAAGiC,QAAQ,CAACM,UAAU,EAAE;MACpC,MAAMuC,QAAQ,GAAG7C,QAAQ,CAACK,QAAQ,EAAE;MACpCL,QAAQ,CAACH,IAAI,EAAE;MACf,IAAIgD,QAAQ,KAAK,QAAQ,EAAE;QACzB1E,KAAK,IAAIqC,IAAI,CAACC,GAAG,CAAC1C,MAAM,EAAEI,KAAK,GAAGyE,MAAM,CAAC;QACzC;OACD,MAAM,IAAIC,QAAQ,KAAK,QAAQ,KAAKD,MAAM,GAAGzE,KAAK,IAAI,CAACsE,QAAQ,CAAC,EAAE;QACjEtE,KAAK,IAAIJ,MAAM;;MAEjB6E,MAAM,IAAI7E,MAAM;;IAElB,OAAOI,KAAK;EACd;;AA/gBOlB,KAAA,CAAAb,EAAE,GAAGD,IAAA,CAAAD,OAAE;AACPe,KAAA,CAAAX,UAAU,GAAGD,YAAA,CAAAH,OAAU;AACvBe,KAAA,CAAAhB,YAAY,GAAGF,cAAA,CAAAG,OAAY;AACnBe,KAAA,CAAAO,QAAQ,GAAmD,EAAE;AA+gB9ExB,OAAA,CAAAE,OAAA,GAAee,KAAK;AAIpB,IAAI,OAAO6F,MAAM,KAAK,QAAQ,EAAE;EAC9BA,MAAM,CAAC9G,OAAO,GAAGiB,KAAK;EACtB6F,MAAM,CAAC9G,OAAO,CAACE,OAAO,GAAGe,KAAK","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}