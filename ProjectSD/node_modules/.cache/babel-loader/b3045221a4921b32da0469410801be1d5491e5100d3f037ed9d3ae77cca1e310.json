{"ast":null,"code":"var Scope = /* @__PURE__ */(Scope2 => (Scope2[Scope2.TYPE = 3] = \"TYPE\", Scope2[Scope2.LEVEL = 12] = \"LEVEL\", Scope2[Scope2.ATTRIBUTE = 13] = \"ATTRIBUTE\", Scope2[Scope2.BLOT = 14] = \"BLOT\", Scope2[Scope2.INLINE = 7] = \"INLINE\", Scope2[Scope2.BLOCK = 11] = \"BLOCK\", Scope2[Scope2.BLOCK_BLOT = 10] = \"BLOCK_BLOT\", Scope2[Scope2.INLINE_BLOT = 6] = \"INLINE_BLOT\", Scope2[Scope2.BLOCK_ATTRIBUTE = 9] = \"BLOCK_ATTRIBUTE\", Scope2[Scope2.INLINE_ATTRIBUTE = 5] = \"INLINE_ATTRIBUTE\", Scope2[Scope2.ANY = 15] = \"ANY\", Scope2))(Scope || {});\nclass Attributor {\n  constructor(attrName, keyName, options = {}) {\n    this.attrName = attrName, this.keyName = keyName;\n    const attributeBit = Scope.TYPE & Scope.ATTRIBUTE;\n    this.scope = options.scope != null ?\n    // Ignore type bits, force attribute bit\n    options.scope & Scope.LEVEL | attributeBit : Scope.ATTRIBUTE, options.whitelist != null && (this.whitelist = options.whitelist);\n  }\n  static keys(node) {\n    return Array.from(node.attributes).map(item => item.name);\n  }\n  add(node, value) {\n    return this.canAdd(node, value) ? (node.setAttribute(this.keyName, value), !0) : !1;\n  }\n  canAdd(_node, value) {\n    return this.whitelist == null ? !0 : typeof value == \"string\" ? this.whitelist.indexOf(value.replace(/[\"']/g, \"\")) > -1 : this.whitelist.indexOf(value) > -1;\n  }\n  remove(node) {\n    node.removeAttribute(this.keyName);\n  }\n  value(node) {\n    const value = node.getAttribute(this.keyName);\n    return this.canAdd(node, value) && value ? value : \"\";\n  }\n}\nclass ParchmentError extends Error {\n  constructor(message) {\n    message = \"[Parchment] \" + message, super(message), this.message = message, this.name = this.constructor.name;\n  }\n}\nconst _Registry = class _Registry {\n  constructor() {\n    this.attributes = {}, this.classes = {}, this.tags = {}, this.types = {};\n  }\n  static find(node, bubble = !1) {\n    if (node == null) return null;\n    if (this.blots.has(node)) return this.blots.get(node) || null;\n    if (bubble) {\n      let parentNode = null;\n      try {\n        parentNode = node.parentNode;\n      } catch {\n        return null;\n      }\n      return this.find(parentNode, bubble);\n    }\n    return null;\n  }\n  create(scroll, input, value) {\n    const match2 = this.query(input);\n    if (match2 == null) throw new ParchmentError(`Unable to create ${input} blot`);\n    const blotClass = match2,\n      node =\n      // @ts-expect-error Fix me later\n      input instanceof Node || input.nodeType === Node.TEXT_NODE ? input : blotClass.create(value),\n      blot = new blotClass(scroll, node, value);\n    return _Registry.blots.set(blot.domNode, blot), blot;\n  }\n  find(node, bubble = !1) {\n    return _Registry.find(node, bubble);\n  }\n  query(query, scope = Scope.ANY) {\n    let match2;\n    return typeof query == \"string\" ? match2 = this.types[query] || this.attributes[query] : query instanceof Text || query.nodeType === Node.TEXT_NODE ? match2 = this.types.text : typeof query == \"number\" ? query & Scope.LEVEL & Scope.BLOCK ? match2 = this.types.block : query & Scope.LEVEL & Scope.INLINE && (match2 = this.types.inline) : query instanceof Element && ((query.getAttribute(\"class\") || \"\").split(/\\s+/).some(name => (match2 = this.classes[name], !!match2)), match2 = match2 || this.tags[query.tagName]), match2 == null ? null : \"scope\" in match2 && scope & Scope.LEVEL & match2.scope && scope & Scope.TYPE & match2.scope ? match2 : null;\n  }\n  register(...definitions) {\n    return definitions.map(definition => {\n      const isBlot = \"blotName\" in definition,\n        isAttr = \"attrName\" in definition;\n      if (!isBlot && !isAttr) throw new ParchmentError(\"Invalid definition\");\n      if (isBlot && definition.blotName === \"abstract\") throw new ParchmentError(\"Cannot register abstract class\");\n      const key = isBlot ? definition.blotName : isAttr ? definition.attrName : void 0;\n      return this.types[key] = definition, isAttr ? typeof definition.keyName == \"string\" && (this.attributes[definition.keyName] = definition) : isBlot && (definition.className && (this.classes[definition.className] = definition), definition.tagName && (Array.isArray(definition.tagName) ? definition.tagName = definition.tagName.map(tagName => tagName.toUpperCase()) : definition.tagName = definition.tagName.toUpperCase(), (Array.isArray(definition.tagName) ? definition.tagName : [definition.tagName]).forEach(tag => {\n        (this.tags[tag] == null || definition.className == null) && (this.tags[tag] = definition);\n      }))), definition;\n    });\n  }\n};\n_Registry.blots = /* @__PURE__ */new WeakMap();\nlet Registry = _Registry;\nfunction match(node, prefix) {\n  return (node.getAttribute(\"class\") || \"\").split(/\\s+/).filter(name => name.indexOf(`${prefix}-`) === 0);\n}\nclass ClassAttributor extends Attributor {\n  static keys(node) {\n    return (node.getAttribute(\"class\") || \"\").split(/\\s+/).map(name => name.split(\"-\").slice(0, -1).join(\"-\"));\n  }\n  add(node, value) {\n    return this.canAdd(node, value) ? (this.remove(node), node.classList.add(`${this.keyName}-${value}`), !0) : !1;\n  }\n  remove(node) {\n    match(node, this.keyName).forEach(name => {\n      node.classList.remove(name);\n    }), node.classList.length === 0 && node.removeAttribute(\"class\");\n  }\n  value(node) {\n    const value = (match(node, this.keyName)[0] || \"\").slice(this.keyName.length + 1);\n    return this.canAdd(node, value) ? value : \"\";\n  }\n}\nconst ClassAttributor$1 = ClassAttributor;\nfunction camelize(name) {\n  const parts = name.split(\"-\"),\n    rest = parts.slice(1).map(part => part[0].toUpperCase() + part.slice(1)).join(\"\");\n  return parts[0] + rest;\n}\nclass StyleAttributor extends Attributor {\n  static keys(node) {\n    return (node.getAttribute(\"style\") || \"\").split(\";\").map(value => value.split(\":\")[0].trim());\n  }\n  add(node, value) {\n    return this.canAdd(node, value) ? (node.style[camelize(this.keyName)] = value, !0) : !1;\n  }\n  remove(node) {\n    node.style[camelize(this.keyName)] = \"\", node.getAttribute(\"style\") || node.removeAttribute(\"style\");\n  }\n  value(node) {\n    const value = node.style[camelize(this.keyName)];\n    return this.canAdd(node, value) ? value : \"\";\n  }\n}\nconst StyleAttributor$1 = StyleAttributor;\nclass AttributorStore {\n  constructor(domNode) {\n    this.attributes = {}, this.domNode = domNode, this.build();\n  }\n  attribute(attribute, value) {\n    value ? attribute.add(this.domNode, value) && (attribute.value(this.domNode) != null ? this.attributes[attribute.attrName] = attribute : delete this.attributes[attribute.attrName]) : (attribute.remove(this.domNode), delete this.attributes[attribute.attrName]);\n  }\n  build() {\n    this.attributes = {};\n    const blot = Registry.find(this.domNode);\n    if (blot == null) return;\n    const attributes = Attributor.keys(this.domNode),\n      classes = ClassAttributor$1.keys(this.domNode),\n      styles = StyleAttributor$1.keys(this.domNode);\n    attributes.concat(classes).concat(styles).forEach(name => {\n      const attr = blot.scroll.query(name, Scope.ATTRIBUTE);\n      attr instanceof Attributor && (this.attributes[attr.attrName] = attr);\n    });\n  }\n  copy(target) {\n    Object.keys(this.attributes).forEach(key => {\n      const value = this.attributes[key].value(this.domNode);\n      target.format(key, value);\n    });\n  }\n  move(target) {\n    this.copy(target), Object.keys(this.attributes).forEach(key => {\n      this.attributes[key].remove(this.domNode);\n    }), this.attributes = {};\n  }\n  values() {\n    return Object.keys(this.attributes).reduce((attributes, name) => (attributes[name] = this.attributes[name].value(this.domNode), attributes), {});\n  }\n}\nconst AttributorStore$1 = AttributorStore,\n  _ShadowBlot = class _ShadowBlot {\n    constructor(scroll, domNode) {\n      this.scroll = scroll, this.domNode = domNode, Registry.blots.set(domNode, this), this.prev = null, this.next = null;\n    }\n    static create(rawValue) {\n      if (this.tagName == null) throw new ParchmentError(\"Blot definition missing tagName\");\n      let node, value;\n      return Array.isArray(this.tagName) ? (typeof rawValue == \"string\" ? (value = rawValue.toUpperCase(), parseInt(value, 10).toString() === value && (value = parseInt(value, 10))) : typeof rawValue == \"number\" && (value = rawValue), typeof value == \"number\" ? node = document.createElement(this.tagName[value - 1]) : value && this.tagName.indexOf(value) > -1 ? node = document.createElement(value) : node = document.createElement(this.tagName[0])) : node = document.createElement(this.tagName), this.className && node.classList.add(this.className), node;\n    }\n    // Hack for accessing inherited static methods\n    get statics() {\n      return this.constructor;\n    }\n    attach() {}\n    clone() {\n      const domNode = this.domNode.cloneNode(!1);\n      return this.scroll.create(domNode);\n    }\n    detach() {\n      this.parent != null && this.parent.removeChild(this), Registry.blots.delete(this.domNode);\n    }\n    deleteAt(index, length) {\n      this.isolate(index, length).remove();\n    }\n    formatAt(index, length, name, value) {\n      const blot = this.isolate(index, length);\n      if (this.scroll.query(name, Scope.BLOT) != null && value) blot.wrap(name, value);else if (this.scroll.query(name, Scope.ATTRIBUTE) != null) {\n        const parent = this.scroll.create(this.statics.scope);\n        blot.wrap(parent), parent.format(name, value);\n      }\n    }\n    insertAt(index, value, def) {\n      const blot = def == null ? this.scroll.create(\"text\", value) : this.scroll.create(value, def),\n        ref = this.split(index);\n      this.parent.insertBefore(blot, ref || void 0);\n    }\n    isolate(index, length) {\n      const target = this.split(index);\n      if (target == null) throw new Error(\"Attempt to isolate at end\");\n      return target.split(length), target;\n    }\n    length() {\n      return 1;\n    }\n    offset(root = this.parent) {\n      return this.parent == null || this === root ? 0 : this.parent.children.offset(this) + this.parent.offset(root);\n    }\n    optimize(_context) {\n      this.statics.requiredContainer && !(this.parent instanceof this.statics.requiredContainer) && this.wrap(this.statics.requiredContainer.blotName);\n    }\n    remove() {\n      this.domNode.parentNode != null && this.domNode.parentNode.removeChild(this.domNode), this.detach();\n    }\n    replaceWith(name, value) {\n      const replacement = typeof name == \"string\" ? this.scroll.create(name, value) : name;\n      return this.parent != null && (this.parent.insertBefore(replacement, this.next || void 0), this.remove()), replacement;\n    }\n    split(index, _force) {\n      return index === 0 ? this : this.next;\n    }\n    update(_mutations, _context) {}\n    wrap(name, value) {\n      const wrapper = typeof name == \"string\" ? this.scroll.create(name, value) : name;\n      if (this.parent != null && this.parent.insertBefore(wrapper, this.next || void 0), typeof wrapper.appendChild != \"function\") throw new ParchmentError(`Cannot wrap ${name}`);\n      return wrapper.appendChild(this), wrapper;\n    }\n  };\n_ShadowBlot.blotName = \"abstract\";\nlet ShadowBlot = _ShadowBlot;\nconst _LeafBlot = class _LeafBlot extends ShadowBlot {\n  /**\n   * Returns the value represented by domNode if it is this Blot's type\n   * No checking that domNode can represent this Blot type is required so\n   * applications needing it should check externally before calling.\n   */\n  static value(_domNode) {\n    return !0;\n  }\n  /**\n   * Given location represented by node and offset from DOM Selection Range,\n   * return index to that location.\n   */\n  index(node, offset) {\n    return this.domNode === node || this.domNode.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY ? Math.min(offset, 1) : -1;\n  }\n  /**\n   * Given index to location within blot, return node and offset representing\n   * that location, consumable by DOM Selection Range\n   */\n  position(index, _inclusive) {\n    let offset = Array.from(this.parent.domNode.childNodes).indexOf(this.domNode);\n    return index > 0 && (offset += 1), [this.parent.domNode, offset];\n  }\n  /**\n   * Return value represented by this blot\n   * Should not change without interaction from API or\n   * user change detectable by update()\n   */\n  value() {\n    return {\n      [this.statics.blotName]: this.statics.value(this.domNode) || !0\n    };\n  }\n};\n_LeafBlot.scope = Scope.INLINE_BLOT;\nlet LeafBlot = _LeafBlot;\nconst LeafBlot$1 = LeafBlot;\nclass LinkedList {\n  constructor() {\n    this.head = null, this.tail = null, this.length = 0;\n  }\n  append(...nodes) {\n    if (this.insertBefore(nodes[0], null), nodes.length > 1) {\n      const rest = nodes.slice(1);\n      this.append(...rest);\n    }\n  }\n  at(index) {\n    const next = this.iterator();\n    let cur = next();\n    for (; cur && index > 0;) index -= 1, cur = next();\n    return cur;\n  }\n  contains(node) {\n    const next = this.iterator();\n    let cur = next();\n    for (; cur;) {\n      if (cur === node) return !0;\n      cur = next();\n    }\n    return !1;\n  }\n  indexOf(node) {\n    const next = this.iterator();\n    let cur = next(),\n      index = 0;\n    for (; cur;) {\n      if (cur === node) return index;\n      index += 1, cur = next();\n    }\n    return -1;\n  }\n  insertBefore(node, refNode) {\n    node != null && (this.remove(node), node.next = refNode, refNode != null ? (node.prev = refNode.prev, refNode.prev != null && (refNode.prev.next = node), refNode.prev = node, refNode === this.head && (this.head = node)) : this.tail != null ? (this.tail.next = node, node.prev = this.tail, this.tail = node) : (node.prev = null, this.head = this.tail = node), this.length += 1);\n  }\n  offset(target) {\n    let index = 0,\n      cur = this.head;\n    for (; cur != null;) {\n      if (cur === target) return index;\n      index += cur.length(), cur = cur.next;\n    }\n    return -1;\n  }\n  remove(node) {\n    this.contains(node) && (node.prev != null && (node.prev.next = node.next), node.next != null && (node.next.prev = node.prev), node === this.head && (this.head = node.next), node === this.tail && (this.tail = node.prev), this.length -= 1);\n  }\n  iterator(curNode = this.head) {\n    return () => {\n      const ret = curNode;\n      return curNode != null && (curNode = curNode.next), ret;\n    };\n  }\n  find(index, inclusive = !1) {\n    const next = this.iterator();\n    let cur = next();\n    for (; cur;) {\n      const length = cur.length();\n      if (index < length || inclusive && index === length && (cur.next == null || cur.next.length() !== 0)) return [cur, index];\n      index -= length, cur = next();\n    }\n    return [null, 0];\n  }\n  forEach(callback) {\n    const next = this.iterator();\n    let cur = next();\n    for (; cur;) callback(cur), cur = next();\n  }\n  forEachAt(index, length, callback) {\n    if (length <= 0) return;\n    const [startNode, offset] = this.find(index);\n    let curIndex = index - offset;\n    const next = this.iterator(startNode);\n    let cur = next();\n    for (; cur && curIndex < index + length;) {\n      const curLength = cur.length();\n      index > curIndex ? callback(cur, index - curIndex, Math.min(length, curIndex + curLength - index)) : callback(cur, 0, Math.min(curLength, index + length - curIndex)), curIndex += curLength, cur = next();\n    }\n  }\n  map(callback) {\n    return this.reduce((memo, cur) => (memo.push(callback(cur)), memo), []);\n  }\n  reduce(callback, memo) {\n    const next = this.iterator();\n    let cur = next();\n    for (; cur;) memo = callback(memo, cur), cur = next();\n    return memo;\n  }\n}\nfunction makeAttachedBlot(node, scroll) {\n  const found = scroll.find(node);\n  if (found) return found;\n  try {\n    return scroll.create(node);\n  } catch {\n    const blot = scroll.create(Scope.INLINE);\n    return Array.from(node.childNodes).forEach(child => {\n      blot.domNode.appendChild(child);\n    }), node.parentNode && node.parentNode.replaceChild(blot.domNode, node), blot.attach(), blot;\n  }\n}\nconst _ParentBlot = class _ParentBlot extends ShadowBlot {\n  constructor(scroll, domNode) {\n    super(scroll, domNode), this.uiNode = null, this.build();\n  }\n  appendChild(other) {\n    this.insertBefore(other);\n  }\n  attach() {\n    super.attach(), this.children.forEach(child => {\n      child.attach();\n    });\n  }\n  attachUI(node) {\n    this.uiNode != null && this.uiNode.remove(), this.uiNode = node, _ParentBlot.uiClass && this.uiNode.classList.add(_ParentBlot.uiClass), this.uiNode.setAttribute(\"contenteditable\", \"false\"), this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n  }\n  /**\n   * Called during construction, should fill its own children LinkedList.\n   */\n  build() {\n    this.children = new LinkedList(), Array.from(this.domNode.childNodes).filter(node => node !== this.uiNode).reverse().forEach(node => {\n      try {\n        const child = makeAttachedBlot(node, this.scroll);\n        this.insertBefore(child, this.children.head || void 0);\n      } catch (err) {\n        if (err instanceof ParchmentError) return;\n        throw err;\n      }\n    });\n  }\n  deleteAt(index, length) {\n    if (index === 0 && length === this.length()) return this.remove();\n    this.children.forEachAt(index, length, (child, offset, childLength) => {\n      child.deleteAt(offset, childLength);\n    });\n  }\n  descendant(criteria, index = 0) {\n    const [child, offset] = this.children.find(index);\n    return criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria ? [child, offset] : child instanceof _ParentBlot ? child.descendant(criteria, offset) : [null, -1];\n  }\n  descendants(criteria, index = 0, length = Number.MAX_VALUE) {\n    let descendants = [],\n      lengthLeft = length;\n    return this.children.forEachAt(index, length, (child, childIndex, childLength) => {\n      (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) && descendants.push(child), child instanceof _ParentBlot && (descendants = descendants.concat(child.descendants(criteria, childIndex, lengthLeft))), lengthLeft -= childLength;\n    }), descendants;\n  }\n  detach() {\n    this.children.forEach(child => {\n      child.detach();\n    }), super.detach();\n  }\n  enforceAllowedChildren() {\n    let done = !1;\n    this.children.forEach(child => {\n      done || this.statics.allowedChildren.some(def => child instanceof def) || (child.statics.scope === Scope.BLOCK_BLOT ? (child.next != null && this.splitAfter(child), child.prev != null && this.splitAfter(child.prev), child.parent.unwrap(), done = !0) : child instanceof _ParentBlot ? child.unwrap() : child.remove());\n    });\n  }\n  formatAt(index, length, name, value) {\n    this.children.forEachAt(index, length, (child, offset, childLength) => {\n      child.formatAt(offset, childLength, name, value);\n    });\n  }\n  insertAt(index, value, def) {\n    const [child, offset] = this.children.find(index);\n    if (child) child.insertAt(offset, value, def);else {\n      const blot = def == null ? this.scroll.create(\"text\", value) : this.scroll.create(value, def);\n      this.appendChild(blot);\n    }\n  }\n  insertBefore(childBlot, refBlot) {\n    childBlot.parent != null && childBlot.parent.children.remove(childBlot);\n    let refDomNode = null;\n    this.children.insertBefore(childBlot, refBlot || null), childBlot.parent = this, refBlot != null && (refDomNode = refBlot.domNode), (this.domNode.parentNode !== childBlot.domNode || this.domNode.nextSibling !== refDomNode) && this.domNode.insertBefore(childBlot.domNode, refDomNode), childBlot.attach();\n  }\n  length() {\n    return this.children.reduce((memo, child) => memo + child.length(), 0);\n  }\n  moveChildren(targetParent, refNode) {\n    this.children.forEach(child => {\n      targetParent.insertBefore(child, refNode);\n    });\n  }\n  optimize(context) {\n    if (super.optimize(context), this.enforceAllowedChildren(), this.uiNode != null && this.uiNode !== this.domNode.firstChild && this.domNode.insertBefore(this.uiNode, this.domNode.firstChild), this.children.length === 0) if (this.statics.defaultChild != null) {\n      const child = this.scroll.create(this.statics.defaultChild.blotName);\n      this.appendChild(child);\n    } else this.remove();\n  }\n  path(index, inclusive = !1) {\n    const [child, offset] = this.children.find(index, inclusive),\n      position = [[this, index]];\n    return child instanceof _ParentBlot ? position.concat(child.path(offset, inclusive)) : (child != null && position.push([child, offset]), position);\n  }\n  removeChild(child) {\n    this.children.remove(child);\n  }\n  replaceWith(name, value) {\n    const replacement = typeof name == \"string\" ? this.scroll.create(name, value) : name;\n    return replacement instanceof _ParentBlot && this.moveChildren(replacement), super.replaceWith(replacement);\n  }\n  split(index, force = !1) {\n    if (!force) {\n      if (index === 0) return this;\n      if (index === this.length()) return this.next;\n    }\n    const after = this.clone();\n    return this.parent && this.parent.insertBefore(after, this.next || void 0), this.children.forEachAt(index, this.length(), (child, offset, _length) => {\n      const split = child.split(offset, force);\n      split != null && after.appendChild(split);\n    }), after;\n  }\n  splitAfter(child) {\n    const after = this.clone();\n    for (; child.next != null;) after.appendChild(child.next);\n    return this.parent && this.parent.insertBefore(after, this.next || void 0), after;\n  }\n  unwrap() {\n    this.parent && this.moveChildren(this.parent, this.next || void 0), this.remove();\n  }\n  update(mutations, _context) {\n    const addedNodes = [],\n      removedNodes = [];\n    mutations.forEach(mutation => {\n      mutation.target === this.domNode && mutation.type === \"childList\" && (addedNodes.push(...mutation.addedNodes), removedNodes.push(...mutation.removedNodes));\n    }), removedNodes.forEach(node => {\n      if (node.parentNode != null &&\n      // @ts-expect-error Fix me later\n      node.tagName !== \"IFRAME\" && document.body.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) return;\n      const blot = this.scroll.find(node);\n      blot != null && (blot.domNode.parentNode == null || blot.domNode.parentNode === this.domNode) && blot.detach();\n    }), addedNodes.filter(node => node.parentNode === this.domNode && node !== this.uiNode).sort((a, b) => a === b ? 0 : a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING ? 1 : -1).forEach(node => {\n      let refBlot = null;\n      node.nextSibling != null && (refBlot = this.scroll.find(node.nextSibling));\n      const blot = makeAttachedBlot(node, this.scroll);\n      (blot.next !== refBlot || blot.next == null) && (blot.parent != null && blot.parent.removeChild(this), this.insertBefore(blot, refBlot || void 0));\n    }), this.enforceAllowedChildren();\n  }\n};\n_ParentBlot.uiClass = \"\";\nlet ParentBlot = _ParentBlot;\nconst ParentBlot$1 = ParentBlot;\nfunction isEqual(obj1, obj2) {\n  if (Object.keys(obj1).length !== Object.keys(obj2).length) return !1;\n  for (const prop in obj1) if (obj1[prop] !== obj2[prop]) return !1;\n  return !0;\n}\nconst _InlineBlot = class _InlineBlot extends ParentBlot$1 {\n  static create(value) {\n    return super.create(value);\n  }\n  static formats(domNode, scroll) {\n    const match2 = scroll.query(_InlineBlot.blotName);\n    if (!(match2 != null && domNode.tagName === match2.tagName)) {\n      if (typeof this.tagName == \"string\") return !0;\n      if (Array.isArray(this.tagName)) return domNode.tagName.toLowerCase();\n    }\n  }\n  constructor(scroll, domNode) {\n    super(scroll, domNode), this.attributes = new AttributorStore$1(this.domNode);\n  }\n  format(name, value) {\n    if (name === this.statics.blotName && !value) this.children.forEach(child => {\n      child instanceof _InlineBlot || (child = child.wrap(_InlineBlot.blotName, !0)), this.attributes.copy(child);\n    }), this.unwrap();else {\n      const format = this.scroll.query(name, Scope.INLINE);\n      if (format == null) return;\n      format instanceof Attributor ? this.attributes.attribute(format, value) : value && (name !== this.statics.blotName || this.formats()[name] !== value) && this.replaceWith(name, value);\n    }\n  }\n  formats() {\n    const formats = this.attributes.values(),\n      format = this.statics.formats(this.domNode, this.scroll);\n    return format != null && (formats[this.statics.blotName] = format), formats;\n  }\n  formatAt(index, length, name, value) {\n    this.formats()[name] != null || this.scroll.query(name, Scope.ATTRIBUTE) ? this.isolate(index, length).format(name, value) : super.formatAt(index, length, name, value);\n  }\n  optimize(context) {\n    super.optimize(context);\n    const formats = this.formats();\n    if (Object.keys(formats).length === 0) return this.unwrap();\n    const next = this.next;\n    next instanceof _InlineBlot && next.prev === this && isEqual(formats, next.formats()) && (next.moveChildren(this), next.remove());\n  }\n  replaceWith(name, value) {\n    const replacement = super.replaceWith(name, value);\n    return this.attributes.copy(replacement), replacement;\n  }\n  update(mutations, context) {\n    super.update(mutations, context), mutations.some(mutation => mutation.target === this.domNode && mutation.type === \"attributes\") && this.attributes.build();\n  }\n  wrap(name, value) {\n    const wrapper = super.wrap(name, value);\n    return wrapper instanceof _InlineBlot && this.attributes.move(wrapper), wrapper;\n  }\n};\n_InlineBlot.allowedChildren = [_InlineBlot, LeafBlot$1], _InlineBlot.blotName = \"inline\", _InlineBlot.scope = Scope.INLINE_BLOT, _InlineBlot.tagName = \"SPAN\";\nlet InlineBlot = _InlineBlot;\nconst InlineBlot$1 = InlineBlot,\n  _BlockBlot = class _BlockBlot extends ParentBlot$1 {\n    static create(value) {\n      return super.create(value);\n    }\n    static formats(domNode, scroll) {\n      const match2 = scroll.query(_BlockBlot.blotName);\n      if (!(match2 != null && domNode.tagName === match2.tagName)) {\n        if (typeof this.tagName == \"string\") return !0;\n        if (Array.isArray(this.tagName)) return domNode.tagName.toLowerCase();\n      }\n    }\n    constructor(scroll, domNode) {\n      super(scroll, domNode), this.attributes = new AttributorStore$1(this.domNode);\n    }\n    format(name, value) {\n      const format = this.scroll.query(name, Scope.BLOCK);\n      format != null && (format instanceof Attributor ? this.attributes.attribute(format, value) : name === this.statics.blotName && !value ? this.replaceWith(_BlockBlot.blotName) : value && (name !== this.statics.blotName || this.formats()[name] !== value) && this.replaceWith(name, value));\n    }\n    formats() {\n      const formats = this.attributes.values(),\n        format = this.statics.formats(this.domNode, this.scroll);\n      return format != null && (formats[this.statics.blotName] = format), formats;\n    }\n    formatAt(index, length, name, value) {\n      this.scroll.query(name, Scope.BLOCK) != null ? this.format(name, value) : super.formatAt(index, length, name, value);\n    }\n    insertAt(index, value, def) {\n      if (def == null || this.scroll.query(value, Scope.INLINE) != null) super.insertAt(index, value, def);else {\n        const after = this.split(index);\n        if (after != null) {\n          const blot = this.scroll.create(value, def);\n          after.parent.insertBefore(blot, after);\n        } else throw new Error(\"Attempt to insertAt after block boundaries\");\n      }\n    }\n    replaceWith(name, value) {\n      const replacement = super.replaceWith(name, value);\n      return this.attributes.copy(replacement), replacement;\n    }\n    update(mutations, context) {\n      super.update(mutations, context), mutations.some(mutation => mutation.target === this.domNode && mutation.type === \"attributes\") && this.attributes.build();\n    }\n  };\n_BlockBlot.blotName = \"block\", _BlockBlot.scope = Scope.BLOCK_BLOT, _BlockBlot.tagName = \"P\", _BlockBlot.allowedChildren = [InlineBlot$1, _BlockBlot, LeafBlot$1];\nlet BlockBlot = _BlockBlot;\nconst BlockBlot$1 = BlockBlot,\n  _ContainerBlot = class _ContainerBlot extends ParentBlot$1 {\n    checkMerge() {\n      return this.next !== null && this.next.statics.blotName === this.statics.blotName;\n    }\n    deleteAt(index, length) {\n      super.deleteAt(index, length), this.enforceAllowedChildren();\n    }\n    formatAt(index, length, name, value) {\n      super.formatAt(index, length, name, value), this.enforceAllowedChildren();\n    }\n    insertAt(index, value, def) {\n      super.insertAt(index, value, def), this.enforceAllowedChildren();\n    }\n    optimize(context) {\n      super.optimize(context), this.children.length > 0 && this.next != null && this.checkMerge() && (this.next.moveChildren(this), this.next.remove());\n    }\n  };\n_ContainerBlot.blotName = \"container\", _ContainerBlot.scope = Scope.BLOCK_BLOT;\nlet ContainerBlot = _ContainerBlot;\nconst ContainerBlot$1 = ContainerBlot;\nclass EmbedBlot extends LeafBlot$1 {\n  static formats(_domNode, _scroll) {}\n  format(name, value) {\n    super.formatAt(0, this.length(), name, value);\n  }\n  formatAt(index, length, name, value) {\n    index === 0 && length === this.length() ? this.format(name, value) : super.formatAt(index, length, name, value);\n  }\n  formats() {\n    return this.statics.formats(this.domNode, this.scroll);\n  }\n}\nconst EmbedBlot$1 = EmbedBlot,\n  OBSERVER_CONFIG = {\n    attributes: !0,\n    characterData: !0,\n    characterDataOldValue: !0,\n    childList: !0,\n    subtree: !0\n  },\n  MAX_OPTIMIZE_ITERATIONS = 100,\n  _ScrollBlot = class _ScrollBlot extends ParentBlot$1 {\n    constructor(registry, node) {\n      super(null, node), this.registry = registry, this.scroll = this, this.build(), this.observer = new MutationObserver(mutations => {\n        this.update(mutations);\n      }), this.observer.observe(this.domNode, OBSERVER_CONFIG), this.attach();\n    }\n    create(input, value) {\n      return this.registry.create(this, input, value);\n    }\n    find(node, bubble = !1) {\n      const blot = this.registry.find(node, bubble);\n      return blot ? blot.scroll === this ? blot : bubble ? this.find(blot.scroll.domNode.parentNode, !0) : null : null;\n    }\n    query(query, scope = Scope.ANY) {\n      return this.registry.query(query, scope);\n    }\n    register(...definitions) {\n      return this.registry.register(...definitions);\n    }\n    build() {\n      this.scroll != null && super.build();\n    }\n    detach() {\n      super.detach(), this.observer.disconnect();\n    }\n    deleteAt(index, length) {\n      this.update(), index === 0 && length === this.length() ? this.children.forEach(child => {\n        child.remove();\n      }) : super.deleteAt(index, length);\n    }\n    formatAt(index, length, name, value) {\n      this.update(), super.formatAt(index, length, name, value);\n    }\n    insertAt(index, value, def) {\n      this.update(), super.insertAt(index, value, def);\n    }\n    optimize(mutations = [], context = {}) {\n      super.optimize(context);\n      const mutationsMap = context.mutationsMap || /* @__PURE__ */new WeakMap();\n      let records = Array.from(this.observer.takeRecords());\n      for (; records.length > 0;) mutations.push(records.pop());\n      const mark = (blot, markParent = !0) => {\n          blot == null || blot === this || blot.domNode.parentNode != null && (mutationsMap.has(blot.domNode) || mutationsMap.set(blot.domNode, []), markParent && mark(blot.parent));\n        },\n        optimize = blot => {\n          mutationsMap.has(blot.domNode) && (blot instanceof ParentBlot$1 && blot.children.forEach(optimize), mutationsMap.delete(blot.domNode), blot.optimize(context));\n        };\n      let remaining = mutations;\n      for (let i = 0; remaining.length > 0; i += 1) {\n        if (i >= MAX_OPTIMIZE_ITERATIONS) throw new Error(\"[Parchment] Maximum optimize iterations reached\");\n        for (remaining.forEach(mutation => {\n          const blot = this.find(mutation.target, !0);\n          blot != null && (blot.domNode === mutation.target && (mutation.type === \"childList\" ? (mark(this.find(mutation.previousSibling, !1)), Array.from(mutation.addedNodes).forEach(node => {\n            const child = this.find(node, !1);\n            mark(child, !1), child instanceof ParentBlot$1 && child.children.forEach(grandChild => {\n              mark(grandChild, !1);\n            });\n          })) : mutation.type === \"attributes\" && mark(blot.prev)), mark(blot));\n        }), this.children.forEach(optimize), remaining = Array.from(this.observer.takeRecords()), records = remaining.slice(); records.length > 0;) mutations.push(records.pop());\n      }\n    }\n    update(mutations, context = {}) {\n      mutations = mutations || this.observer.takeRecords();\n      const mutationsMap = /* @__PURE__ */new WeakMap();\n      mutations.map(mutation => {\n        const blot = this.find(mutation.target, !0);\n        return blot == null ? null : mutationsMap.has(blot.domNode) ? (mutationsMap.get(blot.domNode).push(mutation), null) : (mutationsMap.set(blot.domNode, [mutation]), blot);\n      }).forEach(blot => {\n        blot != null && blot !== this && mutationsMap.has(blot.domNode) && blot.update(mutationsMap.get(blot.domNode) || [], context);\n      }), context.mutationsMap = mutationsMap, mutationsMap.has(this.domNode) && super.update(mutationsMap.get(this.domNode), context), this.optimize(mutations, context);\n    }\n  };\n_ScrollBlot.blotName = \"scroll\", _ScrollBlot.defaultChild = BlockBlot$1, _ScrollBlot.allowedChildren = [BlockBlot$1, ContainerBlot$1], _ScrollBlot.scope = Scope.BLOCK_BLOT, _ScrollBlot.tagName = \"DIV\";\nlet ScrollBlot = _ScrollBlot;\nconst ScrollBlot$1 = ScrollBlot,\n  _TextBlot = class _TextBlot extends LeafBlot$1 {\n    static create(value) {\n      return document.createTextNode(value);\n    }\n    static value(domNode) {\n      return domNode.data;\n    }\n    constructor(scroll, node) {\n      super(scroll, node), this.text = this.statics.value(this.domNode);\n    }\n    deleteAt(index, length) {\n      this.domNode.data = this.text = this.text.slice(0, index) + this.text.slice(index + length);\n    }\n    index(node, offset) {\n      return this.domNode === node ? offset : -1;\n    }\n    insertAt(index, value, def) {\n      def == null ? (this.text = this.text.slice(0, index) + value + this.text.slice(index), this.domNode.data = this.text) : super.insertAt(index, value, def);\n    }\n    length() {\n      return this.text.length;\n    }\n    optimize(context) {\n      super.optimize(context), this.text = this.statics.value(this.domNode), this.text.length === 0 ? this.remove() : this.next instanceof _TextBlot && this.next.prev === this && (this.insertAt(this.length(), this.next.value()), this.next.remove());\n    }\n    position(index, _inclusive = !1) {\n      return [this.domNode, index];\n    }\n    split(index, force = !1) {\n      if (!force) {\n        if (index === 0) return this;\n        if (index === this.length()) return this.next;\n      }\n      const after = this.scroll.create(this.domNode.splitText(index));\n      return this.parent.insertBefore(after, this.next || void 0), this.text = this.statics.value(this.domNode), after;\n    }\n    update(mutations, _context) {\n      mutations.some(mutation => mutation.type === \"characterData\" && mutation.target === this.domNode) && (this.text = this.statics.value(this.domNode));\n    }\n    value() {\n      return this.text;\n    }\n  };\n_TextBlot.blotName = \"text\", _TextBlot.scope = Scope.INLINE_BLOT;\nlet TextBlot = _TextBlot;\nconst TextBlot$1 = TextBlot;\nexport { Attributor, AttributorStore$1 as AttributorStore, BlockBlot$1 as BlockBlot, ClassAttributor$1 as ClassAttributor, ContainerBlot$1 as ContainerBlot, EmbedBlot$1 as EmbedBlot, InlineBlot$1 as InlineBlot, LeafBlot$1 as LeafBlot, ParentBlot$1 as ParentBlot, Registry, Scope, ScrollBlot$1 as ScrollBlot, StyleAttributor$1 as StyleAttributor, TextBlot$1 as TextBlot };","map":{"version":3,"names":["Scope","Scope2","TYPE","LEVEL","ATTRIBUTE","BLOT","INLINE","BLOCK","BLOCK_BLOT","INLINE_BLOT","BLOCK_ATTRIBUTE","INLINE_ATTRIBUTE","ANY","Attributor","constructor","attrName","keyName","options","attributeBit","scope","whitelist","keys","node","Array","from","attributes","map","item","name","add","value","canAdd","setAttribute","_node","indexOf","replace","remove","removeAttribute","getAttribute","ParchmentError","Error","message","_Registry","classes","tags","types","find","bubble","blots","has","get","parentNode","create","scroll","input","match2","query","blotClass","Node","nodeType","TEXT_NODE","blot","set","domNode","Text","text","block","inline","Element","split","some","tagName","register","definitions","definition","isBlot","isAttr","blotName","key","className","isArray","toUpperCase","forEach","tag","WeakMap","Registry","match","prefix","filter","ClassAttributor","slice","join","classList","length","ClassAttributor$1","camelize","parts","rest","part","StyleAttributor","trim","style","StyleAttributor$1","AttributorStore","build","attribute","styles","concat","attr","copy","target","Object","format","move","values","reduce","AttributorStore$1","_ShadowBlot","prev","next","rawValue","parseInt","toString","document","createElement","statics","attach","clone","cloneNode","detach","parent","removeChild","delete","deleteAt","index","isolate","formatAt","wrap","insertAt","def","ref","insertBefore","offset","root","children","optimize","_context","requiredContainer","replaceWith","replacement","_force","update","_mutations","wrapper","appendChild","ShadowBlot","_LeafBlot","_domNode","compareDocumentPosition","DOCUMENT_POSITION_CONTAINED_BY","Math","min","position","_inclusive","childNodes","LeafBlot","LeafBlot$1","LinkedList","head","tail","append","nodes","at","iterator","cur","contains","refNode","curNode","ret","inclusive","callback","forEachAt","startNode","curIndex","curLength","memo","push","makeAttachedBlot","found","child","replaceChild","_ParentBlot","uiNode","other","attachUI","uiClass","firstChild","reverse","err","childLength","descendant","criteria","descendants","Number","MAX_VALUE","lengthLeft","childIndex","enforceAllowedChildren","done","allowedChildren","splitAfter","unwrap","childBlot","refBlot","refDomNode","nextSibling","moveChildren","targetParent","context","defaultChild","path","force","after","_length","mutations","addedNodes","removedNodes","mutation","type","body","sort","a","b","DOCUMENT_POSITION_FOLLOWING","ParentBlot","ParentBlot$1","isEqual","obj1","obj2","prop","_InlineBlot","formats","toLowerCase","InlineBlot","InlineBlot$1","_BlockBlot","BlockBlot","BlockBlot$1","_ContainerBlot","checkMerge","ContainerBlot","ContainerBlot$1","EmbedBlot","_scroll","EmbedBlot$1","OBSERVER_CONFIG","characterData","characterDataOldValue","childList","subtree","MAX_OPTIMIZE_ITERATIONS","_ScrollBlot","registry","observer","MutationObserver","observe","disconnect","mutationsMap","records","takeRecords","pop","mark","markParent","remaining","i","previousSibling","grandChild","ScrollBlot","ScrollBlot$1","_TextBlot","createTextNode","data","splitText","TextBlot","TextBlot$1"],"sources":["C:\\Users\\Agasthya Samyak Jnan\\ProjectSD\\frontend\\node_modules\\parchment\\src\\scope.ts","C:\\Users\\Agasthya Samyak Jnan\\ProjectSD\\frontend\\node_modules\\parchment\\src\\attributor\\attributor.ts","C:\\Users\\Agasthya Samyak Jnan\\ProjectSD\\frontend\\node_modules\\parchment\\src\\error.ts","C:\\Users\\Agasthya Samyak Jnan\\ProjectSD\\frontend\\node_modules\\parchment\\src\\registry.ts","C:\\Users\\Agasthya Samyak Jnan\\ProjectSD\\frontend\\node_modules\\parchment\\src\\attributor\\class.ts","C:\\Users\\Agasthya Samyak Jnan\\ProjectSD\\frontend\\node_modules\\parchment\\src\\attributor\\style.ts","C:\\Users\\Agasthya Samyak Jnan\\ProjectSD\\frontend\\node_modules\\parchment\\src\\attributor\\store.ts","C:\\Users\\Agasthya Samyak Jnan\\ProjectSD\\frontend\\node_modules\\parchment\\src\\blot\\abstract\\shadow.ts","C:\\Users\\Agasthya Samyak Jnan\\ProjectSD\\frontend\\node_modules\\parchment\\src\\blot\\abstract\\leaf.ts","C:\\Users\\Agasthya Samyak Jnan\\ProjectSD\\frontend\\node_modules\\parchment\\src\\collection\\linked-list.ts","C:\\Users\\Agasthya Samyak Jnan\\ProjectSD\\frontend\\node_modules\\parchment\\src\\blot\\abstract\\parent.ts","C:\\Users\\Agasthya Samyak Jnan\\ProjectSD\\frontend\\node_modules\\parchment\\src\\blot\\inline.ts","C:\\Users\\Agasthya Samyak Jnan\\ProjectSD\\frontend\\node_modules\\parchment\\src\\blot\\block.ts","C:\\Users\\Agasthya Samyak Jnan\\ProjectSD\\frontend\\node_modules\\parchment\\src\\blot\\abstract\\container.ts","C:\\Users\\Agasthya Samyak Jnan\\ProjectSD\\frontend\\node_modules\\parchment\\src\\blot\\embed.ts","C:\\Users\\Agasthya Samyak Jnan\\ProjectSD\\frontend\\node_modules\\parchment\\src\\blot\\scroll.ts","C:\\Users\\Agasthya Samyak Jnan\\ProjectSD\\frontend\\node_modules\\parchment\\src\\blot\\text.ts"],"sourcesContent":["enum Scope {\n  TYPE = (1 << 2) - 1, // 0011 Lower two bits\n  LEVEL = ((1 << 2) - 1) << 2, // 1100 Higher two bits\n\n  ATTRIBUTE = (1 << 0) | LEVEL, // 1101\n  BLOT = (1 << 1) | LEVEL, // 1110\n  INLINE = (1 << 2) | TYPE, // 0111\n  BLOCK = (1 << 3) | TYPE, // 1011\n\n  BLOCK_BLOT = BLOCK & BLOT, // 1010\n  INLINE_BLOT = INLINE & BLOT, // 0110\n  BLOCK_ATTRIBUTE = BLOCK & ATTRIBUTE, // 1001\n  INLINE_ATTRIBUTE = INLINE & ATTRIBUTE, // 0101\n\n  ANY = TYPE | LEVEL,\n}\n\nexport default Scope;\n","import Scope from '../scope.js';\n\nexport interface AttributorOptions {\n  scope?: Scope;\n  whitelist?: string[];\n}\n\nexport default class Attributor {\n  public static keys(node: HTMLElement): string[] {\n    return Array.from(node.attributes).map((item: Attr) => item.name);\n  }\n\n  public scope: Scope;\n  public whitelist: string[] | undefined;\n\n  constructor(\n    public readonly attrName: string,\n    public readonly keyName: string,\n    options: AttributorOptions = {},\n  ) {\n    const attributeBit = Scope.TYPE & Scope.ATTRIBUTE;\n    this.scope =\n      options.scope != null\n        ? // Ignore type bits, force attribute bit\n          (options.scope & Scope.LEVEL) | attributeBit\n        : Scope.ATTRIBUTE;\n    if (options.whitelist != null) {\n      this.whitelist = options.whitelist;\n    }\n  }\n\n  public add(node: HTMLElement, value: any): boolean {\n    if (!this.canAdd(node, value)) {\n      return false;\n    }\n    node.setAttribute(this.keyName, value);\n    return true;\n  }\n\n  public canAdd(_node: HTMLElement, value: any): boolean {\n    if (this.whitelist == null) {\n      return true;\n    }\n    if (typeof value === 'string') {\n      return this.whitelist.indexOf(value.replace(/[\"']/g, '')) > -1;\n    } else {\n      return this.whitelist.indexOf(value) > -1;\n    }\n  }\n\n  public remove(node: HTMLElement): void {\n    node.removeAttribute(this.keyName);\n  }\n\n  public value(node: HTMLElement): any {\n    const value = node.getAttribute(this.keyName);\n    if (this.canAdd(node, value) && value) {\n      return value;\n    }\n    return '';\n  }\n}\n","export default class ParchmentError extends Error {\n  public message: string;\n  public name: string;\n  public stack!: string;\n\n  constructor(message: string) {\n    message = '[Parchment] ' + message;\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n  }\n}\n","import Attributor from './attributor/attributor.js';\nimport {\n  type Blot,\n  type BlotConstructor,\n  type Root,\n} from './blot/abstract/blot.js';\nimport ParchmentError from './error.js';\nimport Scope from './scope.js';\n\nexport type RegistryDefinition = Attributor | BlotConstructor;\n\nexport interface RegistryInterface {\n  create(scroll: Root, input: Node | string | Scope, value?: any): Blot;\n  query(query: string | Node | Scope, scope: Scope): RegistryDefinition | null;\n  register(...definitions: any[]): any;\n}\n\nexport default class Registry implements RegistryInterface {\n  public static blots = new WeakMap<Node, Blot>();\n\n  public static find(node?: Node | null, bubble = false): Blot | null {\n    if (node == null) {\n      return null;\n    }\n    if (this.blots.has(node)) {\n      return this.blots.get(node) || null;\n    }\n    if (bubble) {\n      let parentNode: Node | null = null;\n      try {\n        parentNode = node.parentNode;\n      } catch (err) {\n        // Probably hit a permission denied error.\n        // A known case is in Firefox, event targets can be anonymous DIVs\n        // inside an input element.\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=208427\n        return null;\n      }\n      return this.find(parentNode, bubble);\n    }\n    return null;\n  }\n\n  private attributes: { [key: string]: Attributor } = {};\n  private classes: { [key: string]: BlotConstructor } = {};\n  private tags: { [key: string]: BlotConstructor } = {};\n  private types: { [key: string]: RegistryDefinition } = {};\n\n  public create(scroll: Root, input: Node | string | Scope, value?: any): Blot {\n    const match = this.query(input);\n    if (match == null) {\n      throw new ParchmentError(`Unable to create ${input} blot`);\n    }\n    const blotClass = match as BlotConstructor;\n    const node =\n      // @ts-expect-error Fix me later\n      input instanceof Node || input.nodeType === Node.TEXT_NODE\n        ? input\n        : blotClass.create(value);\n\n    const blot = new blotClass(scroll, node as Node, value);\n    Registry.blots.set(blot.domNode, blot);\n    return blot;\n  }\n\n  public find(node: Node | null, bubble = false): Blot | null {\n    return Registry.find(node, bubble);\n  }\n\n  public query(\n    query: string | Node | Scope,\n    scope: Scope = Scope.ANY,\n  ): RegistryDefinition | null {\n    let match;\n    if (typeof query === 'string') {\n      match = this.types[query] || this.attributes[query];\n      // @ts-expect-error Fix me later\n    } else if (query instanceof Text || query.nodeType === Node.TEXT_NODE) {\n      match = this.types.text;\n    } else if (typeof query === 'number') {\n      if (query & Scope.LEVEL & Scope.BLOCK) {\n        match = this.types.block;\n      } else if (query & Scope.LEVEL & Scope.INLINE) {\n        match = this.types.inline;\n      }\n    } else if (query instanceof Element) {\n      const names = (query.getAttribute('class') || '').split(/\\s+/);\n      names.some((name) => {\n        match = this.classes[name];\n        if (match) {\n          return true;\n        }\n        return false;\n      });\n      match = match || this.tags[query.tagName];\n    }\n    if (match == null) {\n      return null;\n    }\n    if (\n      'scope' in match &&\n      scope & Scope.LEVEL & match.scope &&\n      scope & Scope.TYPE & match.scope\n    ) {\n      return match;\n    }\n    return null;\n  }\n\n  public register(...definitions: RegistryDefinition[]): RegistryDefinition[] {\n    return definitions.map((definition) => {\n      const isBlot = 'blotName' in definition;\n      const isAttr = 'attrName' in definition;\n      if (!isBlot && !isAttr) {\n        throw new ParchmentError('Invalid definition');\n      } else if (isBlot && definition.blotName === 'abstract') {\n        throw new ParchmentError('Cannot register abstract class');\n      }\n      const key = isBlot\n        ? definition.blotName\n        : isAttr\n          ? definition.attrName\n          : (undefined as never); // already handled by above checks\n      this.types[key] = definition;\n\n      if (isAttr) {\n        if (typeof definition.keyName === 'string') {\n          this.attributes[definition.keyName] = definition;\n        }\n      } else if (isBlot) {\n        if (definition.className) {\n          this.classes[definition.className] = definition;\n        }\n        if (definition.tagName) {\n          if (Array.isArray(definition.tagName)) {\n            definition.tagName = definition.tagName.map((tagName: string) => {\n              return tagName.toUpperCase();\n            });\n          } else {\n            definition.tagName = definition.tagName.toUpperCase();\n          }\n          const tagNames = Array.isArray(definition.tagName)\n            ? definition.tagName\n            : [definition.tagName];\n          tagNames.forEach((tag: string) => {\n            if (this.tags[tag] == null || definition.className == null) {\n              this.tags[tag] = definition;\n            }\n          });\n        }\n      }\n      return definition;\n    });\n  }\n}\n","import Attributor from './attributor.js';\n\nfunction match(node: HTMLElement, prefix: string): string[] {\n  const className = node.getAttribute('class') || '';\n  return className\n    .split(/\\s+/)\n    .filter((name) => name.indexOf(`${prefix}-`) === 0);\n}\n\nclass ClassAttributor extends Attributor {\n  public static keys(node: HTMLElement): string[] {\n    return (node.getAttribute('class') || '')\n      .split(/\\s+/)\n      .map((name) => name.split('-').slice(0, -1).join('-'));\n  }\n\n  public add(node: HTMLElement, value: any): boolean {\n    if (!this.canAdd(node, value)) {\n      return false;\n    }\n    this.remove(node);\n    node.classList.add(`${this.keyName}-${value}`);\n    return true;\n  }\n\n  public remove(node: HTMLElement): void {\n    const matches = match(node, this.keyName);\n    matches.forEach((name) => {\n      node.classList.remove(name);\n    });\n    if (node.classList.length === 0) {\n      node.removeAttribute('class');\n    }\n  }\n\n  public value(node: HTMLElement): any {\n    const result = match(node, this.keyName)[0] || '';\n    const value = result.slice(this.keyName.length + 1); // +1 for hyphen\n    return this.canAdd(node, value) ? value : '';\n  }\n}\n\nexport default ClassAttributor;\n","import Attributor from './attributor.js';\n\nfunction camelize(name: string): string {\n  const parts = name.split('-');\n  const rest = parts\n    .slice(1)\n    .map((part: string) => part[0].toUpperCase() + part.slice(1))\n    .join('');\n  return parts[0] + rest;\n}\n\nclass StyleAttributor extends Attributor {\n  public static keys(node: HTMLElement): string[] {\n    return (node.getAttribute('style') || '').split(';').map((value) => {\n      const arr = value.split(':');\n      return arr[0].trim();\n    });\n  }\n\n  public add(node: HTMLElement, value: any): boolean {\n    if (!this.canAdd(node, value)) {\n      return false;\n    }\n    // @ts-expect-error Fix me later\n    node.style[camelize(this.keyName)] = value;\n    return true;\n  }\n\n  public remove(node: HTMLElement): void {\n    // @ts-expect-error Fix me later\n    node.style[camelize(this.keyName)] = '';\n    if (!node.getAttribute('style')) {\n      node.removeAttribute('style');\n    }\n  }\n\n  public value(node: HTMLElement): any {\n    // @ts-expect-error Fix me later\n    const value = node.style[camelize(this.keyName)];\n    return this.canAdd(node, value) ? value : '';\n  }\n}\n\nexport default StyleAttributor;\n","import type { Formattable } from '../blot/abstract/blot.js';\nimport Registry from '../registry.js';\nimport Scope from '../scope.js';\nimport Attributor from './attributor.js';\nimport ClassAttributor from './class.js';\nimport StyleAttributor from './style.js';\n\nclass AttributorStore {\n  private attributes: { [key: string]: Attributor } = {};\n  private domNode: HTMLElement;\n\n  constructor(domNode: HTMLElement) {\n    this.domNode = domNode;\n    this.build();\n  }\n\n  public attribute(attribute: Attributor, value: any): void {\n    // verb\n    if (value) {\n      if (attribute.add(this.domNode, value)) {\n        if (attribute.value(this.domNode) != null) {\n          this.attributes[attribute.attrName] = attribute;\n        } else {\n          delete this.attributes[attribute.attrName];\n        }\n      }\n    } else {\n      attribute.remove(this.domNode);\n      delete this.attributes[attribute.attrName];\n    }\n  }\n\n  public build(): void {\n    this.attributes = {};\n    const blot = Registry.find(this.domNode);\n    if (blot == null) {\n      return;\n    }\n    const attributes = Attributor.keys(this.domNode);\n    const classes = ClassAttributor.keys(this.domNode);\n    const styles = StyleAttributor.keys(this.domNode);\n    attributes\n      .concat(classes)\n      .concat(styles)\n      .forEach((name) => {\n        const attr = blot.scroll.query(name, Scope.ATTRIBUTE);\n        if (attr instanceof Attributor) {\n          this.attributes[attr.attrName] = attr;\n        }\n      });\n  }\n\n  public copy(target: Formattable): void {\n    Object.keys(this.attributes).forEach((key) => {\n      const value = this.attributes[key].value(this.domNode);\n      target.format(key, value);\n    });\n  }\n\n  public move(target: Formattable): void {\n    this.copy(target);\n    Object.keys(this.attributes).forEach((key) => {\n      this.attributes[key].remove(this.domNode);\n    });\n    this.attributes = {};\n  }\n\n  public values(): { [key: string]: any } {\n    return Object.keys(this.attributes).reduce(\n      (attributes: { [key: string]: any }, name: string) => {\n        attributes[name] = this.attributes[name].value(this.domNode);\n        return attributes;\n      },\n      {},\n    );\n  }\n}\n\nexport default AttributorStore;\n","import ParchmentError from '../../error.js';\nimport Registry from '../../registry.js';\nimport Scope from '../../scope.js';\nimport type {\n  Blot,\n  BlotConstructor,\n  Formattable,\n  Parent,\n  Root,\n} from './blot.js';\n\nclass ShadowBlot implements Blot {\n  public static blotName = 'abstract';\n  public static className: string;\n  public static requiredContainer: BlotConstructor;\n  public static scope: Scope;\n  public static tagName: string | string[];\n\n  public static create(rawValue?: unknown): Node {\n    if (this.tagName == null) {\n      throw new ParchmentError('Blot definition missing tagName');\n    }\n    let node: HTMLElement;\n    let value: string | number | undefined;\n    if (Array.isArray(this.tagName)) {\n      if (typeof rawValue === 'string') {\n        value = rawValue.toUpperCase();\n        if (parseInt(value, 10).toString() === value) {\n          value = parseInt(value, 10);\n        }\n      } else if (typeof rawValue === 'number') {\n        value = rawValue;\n      }\n      if (typeof value === 'number') {\n        node = document.createElement(this.tagName[value - 1]);\n      } else if (value && this.tagName.indexOf(value) > -1) {\n        node = document.createElement(value);\n      } else {\n        node = document.createElement(this.tagName[0]);\n      }\n    } else {\n      node = document.createElement(this.tagName);\n    }\n    if (this.className) {\n      node.classList.add(this.className);\n    }\n    return node;\n  }\n\n  public prev: Blot | null;\n  public next: Blot | null;\n  // @ts-expect-error Fix me later\n  public parent: Parent;\n\n  // Hack for accessing inherited static methods\n  get statics(): any {\n    return this.constructor;\n  }\n  constructor(\n    public scroll: Root,\n    public domNode: Node,\n  ) {\n    Registry.blots.set(domNode, this);\n    this.prev = null;\n    this.next = null;\n  }\n\n  public attach(): void {\n    // Nothing to do\n  }\n\n  public clone(): Blot {\n    const domNode = this.domNode.cloneNode(false);\n    return this.scroll.create(domNode);\n  }\n\n  public detach(): void {\n    if (this.parent != null) {\n      this.parent.removeChild(this);\n    }\n    Registry.blots.delete(this.domNode);\n  }\n\n  public deleteAt(index: number, length: number): void {\n    const blot = this.isolate(index, length);\n    blot.remove();\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    const blot = this.isolate(index, length);\n    if (this.scroll.query(name, Scope.BLOT) != null && value) {\n      blot.wrap(name, value);\n    } else if (this.scroll.query(name, Scope.ATTRIBUTE) != null) {\n      const parent = this.scroll.create(this.statics.scope) as Parent &\n        Formattable;\n      blot.wrap(parent);\n      parent.format(name, value);\n    }\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    const blot =\n      def == null\n        ? this.scroll.create('text', value)\n        : this.scroll.create(value, def);\n    const ref = this.split(index);\n    this.parent.insertBefore(blot, ref || undefined);\n  }\n\n  public isolate(index: number, length: number): Blot {\n    const target = this.split(index);\n    if (target == null) {\n      throw new Error('Attempt to isolate at end');\n    }\n    target.split(length);\n    return target;\n  }\n\n  public length(): number {\n    return 1;\n  }\n\n  public offset(root: Blot = this.parent): number {\n    if (this.parent == null || this === root) {\n      return 0;\n    }\n    return this.parent.children.offset(this) + this.parent.offset(root);\n  }\n\n  public optimize(_context?: { [key: string]: any }): void {\n    if (\n      this.statics.requiredContainer &&\n      !(this.parent instanceof this.statics.requiredContainer)\n    ) {\n      this.wrap(this.statics.requiredContainer.blotName);\n    }\n  }\n\n  public remove(): void {\n    if (this.domNode.parentNode != null) {\n      this.domNode.parentNode.removeChild(this.domNode);\n    }\n    this.detach();\n  }\n\n  public replaceWith(name: string | Blot, value?: any): Blot {\n    const replacement =\n      typeof name === 'string' ? this.scroll.create(name, value) : name;\n    if (this.parent != null) {\n      this.parent.insertBefore(replacement, this.next || undefined);\n      this.remove();\n    }\n    return replacement;\n  }\n\n  public split(index: number, _force?: boolean): Blot | null {\n    return index === 0 ? this : this.next;\n  }\n\n  public update(\n    _mutations: MutationRecord[],\n    _context: { [key: string]: any },\n  ): void {\n    // Nothing to do by default\n  }\n\n  public wrap(name: string | Parent, value?: any): Parent {\n    const wrapper =\n      typeof name === 'string'\n        ? (this.scroll.create(name, value) as Parent)\n        : name;\n    if (this.parent != null) {\n      this.parent.insertBefore(wrapper, this.next || undefined);\n    }\n    if (typeof wrapper.appendChild !== 'function') {\n      throw new ParchmentError(`Cannot wrap ${name}`);\n    }\n    wrapper.appendChild(this);\n    return wrapper;\n  }\n}\n\nexport default ShadowBlot;\n","import Scope from '../../scope.js';\nimport type { Leaf } from './blot.js';\nimport ShadowBlot from './shadow.js';\n\nclass LeafBlot extends ShadowBlot implements Leaf {\n  public static scope = Scope.INLINE_BLOT;\n\n  /**\n   * Returns the value represented by domNode if it is this Blot's type\n   * No checking that domNode can represent this Blot type is required so\n   * applications needing it should check externally before calling.\n   */\n  public static value(_domNode: Node): any {\n    return true;\n  }\n\n  /**\n   * Given location represented by node and offset from DOM Selection Range,\n   * return index to that location.\n   */\n  public index(node: Node, offset: number): number {\n    if (\n      this.domNode === node ||\n      this.domNode.compareDocumentPosition(node) &\n        Node.DOCUMENT_POSITION_CONTAINED_BY\n    ) {\n      return Math.min(offset, 1);\n    }\n    return -1;\n  }\n\n  /**\n   * Given index to location within blot, return node and offset representing\n   * that location, consumable by DOM Selection Range\n   */\n  public position(index: number, _inclusive?: boolean): [Node, number] {\n    const childNodes: Node[] = Array.from(this.parent.domNode.childNodes);\n    let offset = childNodes.indexOf(this.domNode);\n    if (index > 0) {\n      offset += 1;\n    }\n    return [this.parent.domNode, offset];\n  }\n\n  /**\n   * Return value represented by this blot\n   * Should not change without interaction from API or\n   * user change detectable by update()\n   */\n  public value(): any {\n    return {\n      [this.statics.blotName]: this.statics.value(this.domNode) || true,\n    };\n  }\n}\n\nexport default LeafBlot;\n","import type LinkedNode from './linked-node.js';\n\nclass LinkedList<T extends LinkedNode> {\n  public head: T | null;\n  public tail: T | null;\n  public length: number;\n\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  public append(...nodes: T[]): void {\n    this.insertBefore(nodes[0], null);\n    if (nodes.length > 1) {\n      const rest = nodes.slice(1);\n      this.append(...rest);\n    }\n  }\n\n  public at(index: number): T | null {\n    const next = this.iterator();\n    let cur = next();\n    while (cur && index > 0) {\n      index -= 1;\n      cur = next();\n    }\n    return cur;\n  }\n\n  public contains(node: T): boolean {\n    const next = this.iterator();\n    let cur = next();\n    while (cur) {\n      if (cur === node) {\n        return true;\n      }\n      cur = next();\n    }\n    return false;\n  }\n\n  public indexOf(node: T): number {\n    const next = this.iterator();\n    let cur = next();\n    let index = 0;\n    while (cur) {\n      if (cur === node) {\n        return index;\n      }\n      index += 1;\n      cur = next();\n    }\n    return -1;\n  }\n\n  public insertBefore(node: T | null, refNode: T | null): void {\n    if (node == null) {\n      return;\n    }\n    this.remove(node);\n    node.next = refNode;\n    if (refNode != null) {\n      node.prev = refNode.prev;\n      if (refNode.prev != null) {\n        refNode.prev.next = node;\n      }\n      refNode.prev = node;\n      if (refNode === this.head) {\n        this.head = node;\n      }\n    } else if (this.tail != null) {\n      this.tail.next = node;\n      node.prev = this.tail;\n      this.tail = node;\n    } else {\n      node.prev = null;\n      this.head = this.tail = node;\n    }\n    this.length += 1;\n  }\n\n  public offset(target: T): number {\n    let index = 0;\n    let cur = this.head;\n    while (cur != null) {\n      if (cur === target) {\n        return index;\n      }\n      index += cur.length();\n      cur = cur.next as T;\n    }\n    return -1;\n  }\n\n  public remove(node: T): void {\n    if (!this.contains(node)) {\n      return;\n    }\n    if (node.prev != null) {\n      node.prev.next = node.next;\n    }\n    if (node.next != null) {\n      node.next.prev = node.prev;\n    }\n    if (node === this.head) {\n      this.head = node.next as T;\n    }\n    if (node === this.tail) {\n      this.tail = node.prev as T;\n    }\n    this.length -= 1;\n  }\n\n  public iterator(curNode: T | null = this.head): () => T | null {\n    // TODO use yield when we can\n    return (): T | null => {\n      const ret = curNode;\n      if (curNode != null) {\n        curNode = curNode.next as T;\n      }\n      return ret;\n    };\n  }\n\n  public find(index: number, inclusive = false): [T | null, number] {\n    const next = this.iterator();\n    let cur = next();\n    while (cur) {\n      const length = cur.length();\n      if (\n        index < length ||\n        (inclusive &&\n          index === length &&\n          (cur.next == null || cur.next.length() !== 0))\n      ) {\n        return [cur, index];\n      }\n      index -= length;\n      cur = next();\n    }\n    return [null, 0];\n  }\n\n  public forEach(callback: (cur: T) => void): void {\n    const next = this.iterator();\n    let cur = next();\n    while (cur) {\n      callback(cur);\n      cur = next();\n    }\n  }\n\n  public forEachAt(\n    index: number,\n    length: number,\n    callback: (cur: T, offset: number, length: number) => void,\n  ): void {\n    if (length <= 0) {\n      return;\n    }\n    const [startNode, offset] = this.find(index);\n    let curIndex = index - offset;\n    const next = this.iterator(startNode);\n    let cur = next();\n    while (cur && curIndex < index + length) {\n      const curLength = cur.length();\n      if (index > curIndex) {\n        callback(\n          cur,\n          index - curIndex,\n          Math.min(length, curIndex + curLength - index),\n        );\n      } else {\n        callback(cur, 0, Math.min(curLength, index + length - curIndex));\n      }\n      curIndex += curLength;\n      cur = next();\n    }\n  }\n\n  public map(callback: (cur: T) => any): any[] {\n    return this.reduce((memo: T[], cur: T) => {\n      memo.push(callback(cur));\n      return memo;\n    }, []);\n  }\n\n  public reduce<M>(callback: (memo: M, cur: T) => M, memo: M): M {\n    const next = this.iterator();\n    let cur = next();\n    while (cur) {\n      memo = callback(memo, cur);\n      cur = next();\n    }\n    return memo;\n  }\n}\n\nexport default LinkedList;\n","import LinkedList from '../../collection/linked-list.js';\nimport ParchmentError from '../../error.js';\nimport Scope from '../../scope.js';\nimport type { Blot, BlotConstructor, Parent, Root } from './blot.js';\nimport ShadowBlot from './shadow.js';\n\nfunction makeAttachedBlot(node: Node, scroll: Root): Blot {\n  const found = scroll.find(node);\n  if (found) return found;\n  try {\n    return scroll.create(node);\n  } catch (e) {\n    const blot = scroll.create(Scope.INLINE);\n    Array.from(node.childNodes).forEach((child: Node) => {\n      blot.domNode.appendChild(child);\n    });\n    if (node.parentNode) {\n      node.parentNode.replaceChild(blot.domNode, node);\n    }\n    blot.attach();\n    return blot;\n  }\n}\n\nclass ParentBlot extends ShadowBlot implements Parent {\n  /**\n   * Whitelist array of Blots that can be direct children.\n   */\n  public static allowedChildren?: BlotConstructor[];\n\n  /**\n   * Default child blot to be inserted if this blot becomes empty.\n   */\n  public static defaultChild?: BlotConstructor;\n  public static uiClass = '';\n\n  public children!: LinkedList<Blot>;\n  public domNode!: HTMLElement;\n  public uiNode: HTMLElement | null = null;\n\n  constructor(scroll: Root, domNode: Node) {\n    super(scroll, domNode);\n    this.build();\n  }\n\n  public appendChild(other: Blot): void {\n    this.insertBefore(other);\n  }\n\n  public attach(): void {\n    super.attach();\n    this.children.forEach((child) => {\n      child.attach();\n    });\n  }\n\n  public attachUI(node: HTMLElement): void {\n    if (this.uiNode != null) {\n      this.uiNode.remove();\n    }\n    this.uiNode = node;\n    if (ParentBlot.uiClass) {\n      this.uiNode.classList.add(ParentBlot.uiClass);\n    }\n    this.uiNode.setAttribute('contenteditable', 'false');\n    this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n  }\n\n  /**\n   * Called during construction, should fill its own children LinkedList.\n   */\n  public build(): void {\n    this.children = new LinkedList<Blot>();\n    // Need to be reversed for if DOM nodes already in order\n    Array.from(this.domNode.childNodes)\n      .filter((node: Node) => node !== this.uiNode)\n      .reverse()\n      .forEach((node: Node) => {\n        try {\n          const child = makeAttachedBlot(node, this.scroll);\n          this.insertBefore(child, this.children.head || undefined);\n        } catch (err) {\n          if (err instanceof ParchmentError) {\n            return;\n          } else {\n            throw err;\n          }\n        }\n      });\n  }\n\n  public deleteAt(index: number, length: number): void {\n    if (index === 0 && length === this.length()) {\n      return this.remove();\n    }\n    this.children.forEachAt(index, length, (child, offset, childLength) => {\n      child.deleteAt(offset, childLength);\n    });\n  }\n\n  public descendant<T extends Blot>(\n    criteria: new (...args: any[]) => T,\n    index: number,\n  ): [T | null, number];\n  public descendant(\n    criteria: (blot: Blot) => boolean,\n    index: number,\n  ): [Blot | null, number];\n  public descendant(criteria: any, index = 0): [Blot | null, number] {\n    const [child, offset] = this.children.find(index);\n    if (\n      (criteria.blotName == null && criteria(child)) ||\n      (criteria.blotName != null && child instanceof criteria)\n    ) {\n      return [child as any, offset];\n    } else if (child instanceof ParentBlot) {\n      return child.descendant(criteria, offset);\n    } else {\n      return [null, -1];\n    }\n  }\n\n  public descendants<T extends Blot>(\n    criteria: new (...args: any[]) => T,\n    index?: number,\n    length?: number,\n  ): T[];\n  public descendants(\n    criteria: (blot: Blot) => boolean,\n    index?: number,\n    length?: number,\n  ): Blot[];\n  public descendants(\n    criteria: any,\n    index = 0,\n    length: number = Number.MAX_VALUE,\n  ): Blot[] {\n    let descendants: Blot[] = [];\n    let lengthLeft = length;\n    this.children.forEachAt(\n      index,\n      length,\n      (child: Blot, childIndex: number, childLength: number) => {\n        if (\n          (criteria.blotName == null && criteria(child)) ||\n          (criteria.blotName != null && child instanceof criteria)\n        ) {\n          descendants.push(child);\n        }\n        if (child instanceof ParentBlot) {\n          descendants = descendants.concat(\n            child.descendants(criteria, childIndex, lengthLeft),\n          );\n        }\n        lengthLeft -= childLength;\n      },\n    );\n    return descendants;\n  }\n\n  public detach(): void {\n    this.children.forEach((child) => {\n      child.detach();\n    });\n    super.detach();\n  }\n\n  public enforceAllowedChildren(): void {\n    let done = false;\n    this.children.forEach((child: Blot) => {\n      if (done) {\n        return;\n      }\n      const allowed = this.statics.allowedChildren.some(\n        (def: BlotConstructor) => child instanceof def,\n      );\n      if (allowed) {\n        return;\n      }\n      if (child.statics.scope === Scope.BLOCK_BLOT) {\n        if (child.next != null) {\n          this.splitAfter(child);\n        }\n        if (child.prev != null) {\n          this.splitAfter(child.prev);\n        }\n        child.parent.unwrap();\n        done = true;\n      } else if (child instanceof ParentBlot) {\n        child.unwrap();\n      } else {\n        child.remove();\n      }\n    });\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    this.children.forEachAt(index, length, (child, offset, childLength) => {\n      child.formatAt(offset, childLength, name, value);\n    });\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    const [child, offset] = this.children.find(index);\n    if (child) {\n      child.insertAt(offset, value, def);\n    } else {\n      const blot =\n        def == null\n          ? this.scroll.create('text', value)\n          : this.scroll.create(value, def);\n      this.appendChild(blot);\n    }\n  }\n\n  public insertBefore(childBlot: Blot, refBlot?: Blot | null): void {\n    if (childBlot.parent != null) {\n      childBlot.parent.children.remove(childBlot);\n    }\n    let refDomNode: Node | null = null;\n    this.children.insertBefore(childBlot, refBlot || null);\n    childBlot.parent = this;\n    if (refBlot != null) {\n      refDomNode = refBlot.domNode;\n    }\n    if (\n      this.domNode.parentNode !== childBlot.domNode ||\n      this.domNode.nextSibling !== refDomNode\n    ) {\n      this.domNode.insertBefore(childBlot.domNode, refDomNode);\n    }\n    childBlot.attach();\n  }\n\n  public length(): number {\n    return this.children.reduce((memo, child) => {\n      return memo + child.length();\n    }, 0);\n  }\n\n  public moveChildren(targetParent: Parent, refNode?: Blot | null): void {\n    this.children.forEach((child) => {\n      targetParent.insertBefore(child, refNode);\n    });\n  }\n\n  public optimize(context?: { [key: string]: any }): void {\n    super.optimize(context);\n    this.enforceAllowedChildren();\n    if (this.uiNode != null && this.uiNode !== this.domNode.firstChild) {\n      this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n    }\n    if (this.children.length === 0) {\n      if (this.statics.defaultChild != null) {\n        const child = this.scroll.create(this.statics.defaultChild.blotName);\n        this.appendChild(child);\n        // TODO double check if necessary\n        // child.optimize(context);\n      } else {\n        this.remove();\n      }\n    }\n  }\n\n  public path(index: number, inclusive = false): [Blot, number][] {\n    const [child, offset] = this.children.find(index, inclusive);\n    const position: [Blot, number][] = [[this, index]];\n    if (child instanceof ParentBlot) {\n      return position.concat(child.path(offset, inclusive));\n    } else if (child != null) {\n      position.push([child, offset]);\n    }\n    return position;\n  }\n\n  public removeChild(child: Blot): void {\n    this.children.remove(child);\n  }\n\n  public replaceWith(name: string | Blot, value?: any): Blot {\n    const replacement =\n      typeof name === 'string' ? this.scroll.create(name, value) : name;\n    if (replacement instanceof ParentBlot) {\n      this.moveChildren(replacement);\n    }\n    return super.replaceWith(replacement);\n  }\n\n  public split(index: number, force = false): Blot | null {\n    if (!force) {\n      if (index === 0) {\n        return this;\n      }\n      if (index === this.length()) {\n        return this.next;\n      }\n    }\n    const after = this.clone() as ParentBlot;\n    if (this.parent) {\n      this.parent.insertBefore(after, this.next || undefined);\n    }\n    this.children.forEachAt(index, this.length(), (child, offset, _length) => {\n      const split = child.split(offset, force);\n      if (split != null) {\n        after.appendChild(split);\n      }\n    });\n    return after;\n  }\n\n  public splitAfter(child: Blot): Parent {\n    const after = this.clone() as ParentBlot;\n    while (child.next != null) {\n      after.appendChild(child.next);\n    }\n    if (this.parent) {\n      this.parent.insertBefore(after, this.next || undefined);\n    }\n    return after;\n  }\n\n  public unwrap(): void {\n    if (this.parent) {\n      this.moveChildren(this.parent, this.next || undefined);\n    }\n    this.remove();\n  }\n\n  public update(\n    mutations: MutationRecord[],\n    _context: { [key: string]: any },\n  ): void {\n    const addedNodes: Node[] = [];\n    const removedNodes: Node[] = [];\n    mutations.forEach((mutation) => {\n      if (mutation.target === this.domNode && mutation.type === 'childList') {\n        addedNodes.push(...mutation.addedNodes);\n        removedNodes.push(...mutation.removedNodes);\n      }\n    });\n    removedNodes.forEach((node: Node) => {\n      // Check node has actually been removed\n      // One exception is Chrome does not immediately remove IFRAMEs\n      // from DOM but MutationRecord is correct in its reported removal\n      if (\n        node.parentNode != null &&\n        // @ts-expect-error Fix me later\n        node.tagName !== 'IFRAME' &&\n        document.body.compareDocumentPosition(node) &\n          Node.DOCUMENT_POSITION_CONTAINED_BY\n      ) {\n        return;\n      }\n      const blot = this.scroll.find(node);\n      if (blot == null) {\n        return;\n      }\n      if (\n        blot.domNode.parentNode == null ||\n        blot.domNode.parentNode === this.domNode\n      ) {\n        blot.detach();\n      }\n    });\n    addedNodes\n      .filter((node) => {\n        return node.parentNode === this.domNode && node !== this.uiNode;\n      })\n      .sort((a, b) => {\n        if (a === b) {\n          return 0;\n        }\n        if (a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING) {\n          return 1;\n        }\n        return -1;\n      })\n      .forEach((node) => {\n        let refBlot: Blot | null = null;\n        if (node.nextSibling != null) {\n          refBlot = this.scroll.find(node.nextSibling);\n        }\n        const blot = makeAttachedBlot(node, this.scroll);\n        if (blot.next !== refBlot || blot.next == null) {\n          if (blot.parent != null) {\n            blot.parent.removeChild(this);\n          }\n          this.insertBefore(blot, refBlot || undefined);\n        }\n      });\n    this.enforceAllowedChildren();\n  }\n}\n\nexport default ParentBlot;\n","import Attributor from '../attributor/attributor.js';\nimport AttributorStore from '../attributor/store.js';\nimport Scope from '../scope.js';\nimport type {\n  Blot,\n  BlotConstructor,\n  Formattable,\n  Parent,\n  Root,\n} from './abstract/blot.js';\nimport LeafBlot from './abstract/leaf.js';\nimport ParentBlot from './abstract/parent.js';\n\n// Shallow object comparison\nfunction isEqual(\n  obj1: Record<string, unknown>,\n  obj2: Record<string, unknown>,\n): boolean {\n  if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n    return false;\n  }\n  for (const prop in obj1) {\n    if (obj1[prop] !== obj2[prop]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nclass InlineBlot extends ParentBlot implements Formattable {\n  public static allowedChildren: BlotConstructor[] = [InlineBlot, LeafBlot];\n  public static blotName = 'inline';\n  public static scope = Scope.INLINE_BLOT;\n  public static tagName: string | string[] = 'SPAN';\n\n  static create(value?: unknown) {\n    return super.create(value) as HTMLElement;\n  }\n\n  public static formats(domNode: HTMLElement, scroll: Root): any {\n    const match = scroll.query(InlineBlot.blotName);\n    if (\n      match != null &&\n      domNode.tagName === (match as BlotConstructor).tagName\n    ) {\n      return undefined;\n    } else if (typeof this.tagName === 'string') {\n      return true;\n    } else if (Array.isArray(this.tagName)) {\n      return domNode.tagName.toLowerCase();\n    }\n    return undefined;\n  }\n\n  protected attributes: AttributorStore;\n\n  constructor(scroll: Root, domNode: Node) {\n    super(scroll, domNode);\n    this.attributes = new AttributorStore(this.domNode);\n  }\n\n  public format(name: string, value: any): void {\n    if (name === this.statics.blotName && !value) {\n      this.children.forEach((child) => {\n        if (!(child instanceof InlineBlot)) {\n          child = child.wrap(InlineBlot.blotName, true);\n        }\n        this.attributes.copy(child as InlineBlot);\n      });\n      this.unwrap();\n    } else {\n      const format = this.scroll.query(name, Scope.INLINE);\n      if (format == null) {\n        return;\n      }\n      if (format instanceof Attributor) {\n        this.attributes.attribute(format, value);\n      } else if (\n        value &&\n        (name !== this.statics.blotName || this.formats()[name] !== value)\n      ) {\n        this.replaceWith(name, value);\n      }\n    }\n  }\n\n  public formats(): { [index: string]: any } {\n    const formats = this.attributes.values();\n    const format = this.statics.formats(this.domNode, this.scroll);\n    if (format != null) {\n      formats[this.statics.blotName] = format;\n    }\n    return formats;\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    if (\n      this.formats()[name] != null ||\n      this.scroll.query(name, Scope.ATTRIBUTE)\n    ) {\n      const blot = this.isolate(index, length) as InlineBlot;\n      blot.format(name, value);\n    } else {\n      super.formatAt(index, length, name, value);\n    }\n  }\n\n  public optimize(context: { [key: string]: any }): void {\n    super.optimize(context);\n    const formats = this.formats();\n    if (Object.keys(formats).length === 0) {\n      return this.unwrap(); // unformatted span\n    }\n    const next = this.next;\n    if (\n      next instanceof InlineBlot &&\n      next.prev === this &&\n      isEqual(formats, next.formats())\n    ) {\n      next.moveChildren(this);\n      next.remove();\n    }\n  }\n\n  public replaceWith(name: string | Blot, value?: any): Blot {\n    const replacement = super.replaceWith(name, value) as InlineBlot;\n    this.attributes.copy(replacement);\n    return replacement;\n  }\n\n  public update(\n    mutations: MutationRecord[],\n    context: { [key: string]: any },\n  ): void {\n    super.update(mutations, context);\n    const attributeChanged = mutations.some(\n      (mutation) =>\n        mutation.target === this.domNode && mutation.type === 'attributes',\n    );\n    if (attributeChanged) {\n      this.attributes.build();\n    }\n  }\n\n  public wrap(name: string | Parent, value?: any): Parent {\n    const wrapper = super.wrap(name, value);\n    if (wrapper instanceof InlineBlot) {\n      this.attributes.move(wrapper);\n    }\n    return wrapper;\n  }\n}\n\nexport default InlineBlot;\n","import Attributor from '../attributor/attributor.js';\nimport AttributorStore from '../attributor/store.js';\nimport Scope from '../scope.js';\nimport type {\n  Blot,\n  BlotConstructor,\n  Formattable,\n  Root,\n} from './abstract/blot.js';\nimport LeafBlot from './abstract/leaf.js';\nimport ParentBlot from './abstract/parent.js';\nimport InlineBlot from './inline.js';\n\nclass BlockBlot extends ParentBlot implements Formattable {\n  public static blotName = 'block';\n  public static scope = Scope.BLOCK_BLOT;\n  public static tagName: string | string[] = 'P';\n  public static allowedChildren: BlotConstructor[] = [\n    InlineBlot,\n    BlockBlot,\n    LeafBlot,\n  ];\n\n  static create(value?: unknown) {\n    return super.create(value) as HTMLElement;\n  }\n\n  public static formats(domNode: HTMLElement, scroll: Root): any {\n    const match = scroll.query(BlockBlot.blotName);\n    if (\n      match != null &&\n      domNode.tagName === (match as BlotConstructor).tagName\n    ) {\n      return undefined;\n    } else if (typeof this.tagName === 'string') {\n      return true;\n    } else if (Array.isArray(this.tagName)) {\n      return domNode.tagName.toLowerCase();\n    }\n  }\n\n  protected attributes: AttributorStore;\n\n  constructor(scroll: Root, domNode: Node) {\n    super(scroll, domNode);\n    this.attributes = new AttributorStore(this.domNode);\n  }\n\n  public format(name: string, value: any): void {\n    const format = this.scroll.query(name, Scope.BLOCK);\n    if (format == null) {\n      return;\n    } else if (format instanceof Attributor) {\n      this.attributes.attribute(format, value);\n    } else if (name === this.statics.blotName && !value) {\n      this.replaceWith(BlockBlot.blotName);\n    } else if (\n      value &&\n      (name !== this.statics.blotName || this.formats()[name] !== value)\n    ) {\n      this.replaceWith(name, value);\n    }\n  }\n\n  public formats(): { [index: string]: any } {\n    const formats = this.attributes.values();\n    const format = this.statics.formats(this.domNode, this.scroll);\n    if (format != null) {\n      formats[this.statics.blotName] = format;\n    }\n    return formats;\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    if (this.scroll.query(name, Scope.BLOCK) != null) {\n      this.format(name, value);\n    } else {\n      super.formatAt(index, length, name, value);\n    }\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    if (def == null || this.scroll.query(value, Scope.INLINE) != null) {\n      // Insert text or inline\n      super.insertAt(index, value, def);\n    } else {\n      const after = this.split(index);\n      if (after != null) {\n        const blot = this.scroll.create(value, def);\n        after.parent.insertBefore(blot, after);\n      } else {\n        throw new Error('Attempt to insertAt after block boundaries');\n      }\n    }\n  }\n\n  public replaceWith(name: string | Blot, value?: any): Blot {\n    const replacement = super.replaceWith(name, value) as BlockBlot;\n    this.attributes.copy(replacement);\n    return replacement;\n  }\n\n  public update(\n    mutations: MutationRecord[],\n    context: { [key: string]: any },\n  ): void {\n    super.update(mutations, context);\n    const attributeChanged = mutations.some(\n      (mutation) =>\n        mutation.target === this.domNode && mutation.type === 'attributes',\n    );\n    if (attributeChanged) {\n      this.attributes.build();\n    }\n  }\n}\n\nexport default BlockBlot;\n","import Scope from '../../scope.js';\nimport BlockBlot from '../block.js';\nimport ParentBlot from './parent.js';\n\nclass ContainerBlot extends ParentBlot {\n  public static blotName = 'container';\n  public static scope = Scope.BLOCK_BLOT;\n  public static tagName: string | string[];\n\n  public prev!: BlockBlot | ContainerBlot | null;\n  public next!: BlockBlot | ContainerBlot | null;\n\n  public checkMerge(): boolean {\n    return (\n      this.next !== null && this.next.statics.blotName === this.statics.blotName\n    );\n  }\n\n  public deleteAt(index: number, length: number): void {\n    super.deleteAt(index, length);\n    this.enforceAllowedChildren();\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    super.formatAt(index, length, name, value);\n    this.enforceAllowedChildren();\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    super.insertAt(index, value, def);\n    this.enforceAllowedChildren();\n  }\n\n  public optimize(context: { [key: string]: any }): void {\n    super.optimize(context);\n    if (this.children.length > 0 && this.next != null && this.checkMerge()) {\n      this.next.moveChildren(this);\n      this.next.remove();\n    }\n  }\n}\n\nexport default ContainerBlot;\n","import type { Formattable, Root } from './abstract/blot.js';\nimport LeafBlot from './abstract/leaf.js';\n\nclass EmbedBlot extends LeafBlot implements Formattable {\n  public static formats(_domNode: HTMLElement, _scroll: Root): any {\n    return undefined;\n  }\n\n  public format(name: string, value: any): void {\n    // super.formatAt wraps, which is what we want in general,\n    // but this allows subclasses to overwrite for formats\n    // that just apply to particular embeds\n    super.formatAt(0, this.length(), name, value);\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    if (index === 0 && length === this.length()) {\n      this.format(name, value);\n    } else {\n      super.formatAt(index, length, name, value);\n    }\n  }\n\n  public formats(): { [index: string]: any } {\n    return this.statics.formats(this.domNode, this.scroll);\n  }\n}\n\nexport default EmbedBlot;\n","import Registry, { type RegistryDefinition } from '../registry.js';\nimport Scope from '../scope.js';\nimport type { Blot, BlotConstructor, Root } from './abstract/blot.js';\nimport ContainerBlot from './abstract/container.js';\nimport ParentBlot from './abstract/parent.js';\nimport BlockBlot from './block.js';\n\nconst OBSERVER_CONFIG = {\n  attributes: true,\n  characterData: true,\n  characterDataOldValue: true,\n  childList: true,\n  subtree: true,\n};\n\nconst MAX_OPTIMIZE_ITERATIONS = 100;\n\nclass ScrollBlot extends ParentBlot implements Root {\n  public static blotName = 'scroll';\n  public static defaultChild = BlockBlot;\n  public static allowedChildren: BlotConstructor[] = [BlockBlot, ContainerBlot];\n  public static scope = Scope.BLOCK_BLOT;\n  public static tagName = 'DIV';\n\n  public observer: MutationObserver;\n\n  constructor(\n    public registry: Registry,\n    node: HTMLDivElement,\n  ) {\n    // @ts-expect-error scroll is the root with no parent\n    super(null, node);\n    this.scroll = this;\n    this.build();\n    this.observer = new MutationObserver((mutations: MutationRecord[]) => {\n      this.update(mutations);\n    });\n    this.observer.observe(this.domNode, OBSERVER_CONFIG);\n    this.attach();\n  }\n\n  public create(input: Node | string | Scope, value?: any): Blot {\n    return this.registry.create(this, input, value);\n  }\n\n  public find(node: Node | null, bubble = false): Blot | null {\n    const blot = this.registry.find(node, bubble);\n    if (!blot) {\n      return null;\n    }\n    if (blot.scroll === this) {\n      return blot;\n    }\n    return bubble ? this.find(blot.scroll.domNode.parentNode, true) : null;\n  }\n\n  public query(\n    query: string | Node | Scope,\n    scope: Scope = Scope.ANY,\n  ): RegistryDefinition | null {\n    return this.registry.query(query, scope);\n  }\n\n  public register(...definitions: RegistryDefinition[]) {\n    return this.registry.register(...definitions);\n  }\n\n  public build(): void {\n    if (this.scroll == null) {\n      return;\n    }\n    super.build();\n  }\n\n  public detach(): void {\n    super.detach();\n    this.observer.disconnect();\n  }\n\n  public deleteAt(index: number, length: number): void {\n    this.update();\n    if (index === 0 && length === this.length()) {\n      this.children.forEach((child) => {\n        child.remove();\n      });\n    } else {\n      super.deleteAt(index, length);\n    }\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    this.update();\n    super.formatAt(index, length, name, value);\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    this.update();\n    super.insertAt(index, value, def);\n  }\n\n  public optimize(context?: { [key: string]: any }): void;\n  public optimize(\n    mutations: MutationRecord[],\n    context: { [key: string]: any },\n  ): void;\n  public optimize(mutations: any = [], context: any = {}): void {\n    super.optimize(context);\n    const mutationsMap = context.mutationsMap || new WeakMap();\n    // We must modify mutations directly, cannot make copy and then modify\n    let records = Array.from(this.observer.takeRecords());\n    // Array.push currently seems to be implemented by a non-tail recursive function\n    // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());\n    while (records.length > 0) {\n      mutations.push(records.pop());\n    }\n    const mark = (blot: Blot | null, markParent = true): void => {\n      if (blot == null || blot === this) {\n        return;\n      }\n      if (blot.domNode.parentNode == null) {\n        return;\n      }\n      if (!mutationsMap.has(blot.domNode)) {\n        mutationsMap.set(blot.domNode, []);\n      }\n      if (markParent) {\n        mark(blot.parent);\n      }\n    };\n    const optimize = (blot: Blot): void => {\n      // Post-order traversal\n      if (!mutationsMap.has(blot.domNode)) {\n        return;\n      }\n      if (blot instanceof ParentBlot) {\n        blot.children.forEach(optimize);\n      }\n      mutationsMap.delete(blot.domNode);\n      blot.optimize(context);\n    };\n    let remaining = mutations;\n    for (let i = 0; remaining.length > 0; i += 1) {\n      if (i >= MAX_OPTIMIZE_ITERATIONS) {\n        throw new Error('[Parchment] Maximum optimize iterations reached');\n      }\n      remaining.forEach((mutation: MutationRecord) => {\n        const blot = this.find(mutation.target, true);\n        if (blot == null) {\n          return;\n        }\n        if (blot.domNode === mutation.target) {\n          if (mutation.type === 'childList') {\n            mark(this.find(mutation.previousSibling, false));\n            Array.from(mutation.addedNodes).forEach((node: Node) => {\n              const child = this.find(node, false);\n              mark(child, false);\n              if (child instanceof ParentBlot) {\n                child.children.forEach((grandChild: Blot) => {\n                  mark(grandChild, false);\n                });\n              }\n            });\n          } else if (mutation.type === 'attributes') {\n            mark(blot.prev);\n          }\n        }\n        mark(blot);\n      });\n      this.children.forEach(optimize);\n      remaining = Array.from(this.observer.takeRecords());\n      records = remaining.slice();\n      while (records.length > 0) {\n        mutations.push(records.pop());\n      }\n    }\n  }\n\n  public update(\n    mutations?: MutationRecord[],\n    context: { [key: string]: any } = {},\n  ): void {\n    mutations = mutations || this.observer.takeRecords();\n    const mutationsMap = new WeakMap();\n    mutations\n      .map((mutation: MutationRecord) => {\n        const blot = this.find(mutation.target, true);\n        if (blot == null) {\n          return null;\n        }\n        if (mutationsMap.has(blot.domNode)) {\n          mutationsMap.get(blot.domNode).push(mutation);\n          return null;\n        } else {\n          mutationsMap.set(blot.domNode, [mutation]);\n          return blot;\n        }\n      })\n      .forEach((blot: Blot | null) => {\n        if (blot != null && blot !== this && mutationsMap.has(blot.domNode)) {\n          blot.update(mutationsMap.get(blot.domNode) || [], context);\n        }\n      });\n    context.mutationsMap = mutationsMap;\n    if (mutationsMap.has(this.domNode)) {\n      super.update(mutationsMap.get(this.domNode), context);\n    }\n    this.optimize(mutations, context);\n  }\n}\n\nexport default ScrollBlot;\n","import Scope from '../scope.js';\nimport type { Blot, Leaf, Root } from './abstract/blot.js';\nimport LeafBlot from './abstract/leaf.js';\n\nclass TextBlot extends LeafBlot implements Leaf {\n  public static readonly blotName = 'text';\n  public static scope = Scope.INLINE_BLOT;\n\n  public static create(value: string): Text {\n    return document.createTextNode(value);\n  }\n\n  public static value(domNode: Text): string {\n    return domNode.data;\n  }\n\n  public domNode!: Text;\n  protected text: string;\n\n  constructor(scroll: Root, node: Node) {\n    super(scroll, node);\n    this.text = this.statics.value(this.domNode);\n  }\n\n  public deleteAt(index: number, length: number): void {\n    this.domNode.data = this.text =\n      this.text.slice(0, index) + this.text.slice(index + length);\n  }\n\n  public index(node: Node, offset: number): number {\n    if (this.domNode === node) {\n      return offset;\n    }\n    return -1;\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    if (def == null) {\n      this.text = this.text.slice(0, index) + value + this.text.slice(index);\n      this.domNode.data = this.text;\n    } else {\n      super.insertAt(index, value, def);\n    }\n  }\n\n  public length(): number {\n    return this.text.length;\n  }\n\n  public optimize(context: { [key: string]: any }): void {\n    super.optimize(context);\n    this.text = this.statics.value(this.domNode);\n    if (this.text.length === 0) {\n      this.remove();\n    } else if (this.next instanceof TextBlot && this.next.prev === this) {\n      this.insertAt(this.length(), (this.next as TextBlot).value());\n      this.next.remove();\n    }\n  }\n\n  public position(index: number, _inclusive = false): [Node, number] {\n    return [this.domNode, index];\n  }\n\n  public split(index: number, force = false): Blot | null {\n    if (!force) {\n      if (index === 0) {\n        return this;\n      }\n      if (index === this.length()) {\n        return this.next;\n      }\n    }\n    const after = this.scroll.create(this.domNode.splitText(index));\n    this.parent.insertBefore(after, this.next || undefined);\n    this.text = this.statics.value(this.domNode);\n    return after;\n  }\n\n  public update(\n    mutations: MutationRecord[],\n    _context: { [key: string]: any },\n  ): void {\n    if (\n      mutations.some((mutation) => {\n        return (\n          mutation.type === 'characterData' && mutation.target === this.domNode\n        );\n      })\n    ) {\n      this.text = this.statics.value(this.domNode);\n    }\n  }\n\n  public value(): string {\n    return this.text;\n  }\n}\n\nexport default TextBlot;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}